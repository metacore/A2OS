MODULE OPB IN Oberon;
	IMPORT SYSTEM, OPT, OPS, OPM;
CONST 
	AwaitIF* = TRUE; 
	times = 1; 
	slash = 2; 
	div = 3; 
	mod = 4; 
	and = 5; 
	plus = 6; 
	minus = 7; 
	or = 8; 
	eql = 9; 
	neq = 10; 
	lss = 11; 
	leq = 12; 
	gtr = 13; 
	geq = 14; 
	in = 15; 
	is = 16; 
	ash = 17; 
	msk = 18; 
	len = 19; 
	conv = 20; 
	abs = 21; 
	cap = 22; 
	odd = 23; 
	not = 33; 
	adr = 24; 
	cc = 25; 
	bit = 26; 
	lsh = 27; 
	rot = 28; 
	val = 29; 
	get8 = 30; 
	get16 = 31; 
	get32 = 32; 
	type = 34; 
	Var = 1; 
	VarPar = 2; 
	Con = 3; 
	Fld = 4; 
	Typ = 5; 
	LProc = 6; 
	XProc = 7; 
	SProc = 8; 
	CProc = 9; 
	IProc = 10; 
	Mod = 11; 
	Head = 12; 
	TProc = 13; 
	Undef = 0; 
	Byte = 1; 
	Bool = 2; 
	Char = 3; 
	SInt = 4; 
	Int = 5; 
	LInt = 6; 
	Real = 7; 
	LReal = 8; 
	Set = 9; 
	String = 10; 
	NilTyp = 11; 
	NoTyp = 12; 
	Pointer = 13; 
	ProcTyp = 14; 
	Comp = 15; 
	HInt = 16; 
	intSet = {SInt .. LInt}; 
	realSet = {Real, LReal}; 
	Basic = 1; 
	StaticArr = 2; 
	SDynArr = 3; 
	DynArr = 4; 
	OpenArr = 5; 
	Record = 6; 
	ArraySet = {StaticArr, SDynArr, DynArr, OpenArr}; 
	Nvar = 0; 
	Nvarpar = 1; 
	Nfield = 2; 
	Nderef = 3; 
	Nindex = 4; 
	Nguard = 5; 
	Neguard = 6; 
	Nconst = 7; 
	Ntype = 8; 
	Nproc = 9; 
	Nupto = 10; 
	Nmop = 11; 
	Ndop = 12; 
	Ncall = 13; 
	Ninittd = 14; 
	Nif = 15; 
	Ncaselse = 16; 
	Ncasedo = 17; 
	Nenter = 18; 
	Nassign = 19; 
	Nifelse = 20; 
	Ncase = 21; 
	Nwhile = 22; 
	Nrepeat = 23; 
	Nloop = 24; 
	Nexit = 25; 
	Nreturn = 26; 
	Nwith = 27; 
	Ntrap = 28; 
	Nfixup = 31; 
	Nfinally = 40; 
	assign = 0; 
	haltfn = 0; 
	newfn = 1; 
	absfn = 2; 
	capfn = 3; 
	ordfn = 4; 
	entierfn = 5; 
	oddfn = 6; 
	minfn = 7; 
	maxfn = 8; 
	chrfn = 9; 
	shortfn = 10; 
	longfn = 11; 
	sizefn = 12; 
	incfn = 13; 
	decfn = 14; 
	inclfn = 15; 
	exclfn = 16; 
	lenfn = 17; 
	copyfn = 18; 
	ashfn = 19; 
	assertfn = 32; 
	awaitfn = 64; 
	lockfn = 66; 
	adrfn = 20; 
	ccfn = 21; 
	lshfn = 22; 
	rotfn = 23; 
	getfn = 24; 
	putfn = 25; 
	getrfn = 26; 
	putrfn = 27; 
	bitfn = 28; 
	valfn = 29; 
	sysnewfn = 30; 
	movefn = 31; 
	stifn = 33; 
	clifn = 34; 
	poutfn = 35; 
	pinfn = 36; 
	shalt = 37; 
	get8fn = 38; 
	get16fn = 39; 
	get32fn = 40; 
	put8fn = 41; 
	put16fn = 42; 
	put32fn = 43; 
	typefn = 44; 
	internal = 0; 
	external = 1; 
	externalR = 2; 
	hasBody = 1; 
	isRedef = 2; 
	slNeeded = 3; 
	ovflchk = 1; 
	AssertTrap = 8; 
	notag = 1; 
	stdcall = 2; 
	cdecl = 3; 
	delegate = 5; 
VAR 
	typSize*: PROCEDURE (typ: OPT.Struct; allocDesc: BOOLEAN); 
	verify*: PROCEDURE (VAR obj: OPT.Object); 
	exp: INTEGER; 
	maxExp: LONGINT; 
	InitPar: OPT.Object; 

	PROCEDURE ^ err(n: INTEGER); 
	PROCEDURE ^ InitInsert*(VAR stat: OPT.Node); 
	PROCEDURE ^ CodeInsert*(VAR stat: OPT.Node); 
	PROCEDURE ^ InitAppend(VAR x: OPT.Node); 
	PROCEDURE ^ NewLeaf*(obj: OPT.Object): OPT.Node; 
	PROCEDURE ^ Construct*(class: SHORTINT; VAR x: OPT.Node; y: OPT.Node); 
	PROCEDURE ^ Link*(VAR x, last: OPT.Node; y: OPT.Node); 
	PROCEDURE ^ BoolToInt(b: BOOLEAN): LONGINT; 
	PROCEDURE ^ IntToBool(i: LONGINT): BOOLEAN; 
	PROCEDURE ^ NewBoolConst*(boolval: BOOLEAN): OPT.Node; 
	PROCEDURE ^ OptIf*(VAR x: OPT.Node); 
	PROCEDURE ^ Nil*(): OPT.Node; 
	PROCEDURE ^ BoolConst*(value: INTEGER): OPT.Node; 
	PROCEDURE ^ EmptySet*(): OPT.Node; 
	PROCEDURE ^ SetIntType(node: OPT.Node); 
	PROCEDURE ^ NewIntConst*(intval: LONGINT): OPT.Node; 
	PROCEDURE ^ NewRealConst*(realval: LONGREAL; typ: OPT.Struct): OPT.Node; 
	PROCEDURE ^ NewString*(VAR str: OPS.String; len: LONGINT): OPT.Node; 
	PROCEDURE ^ CharToString(n: OPT.Node); 
	PROCEDURE ^ BindNodes(class: SHORTINT; typ: OPT.Struct; VAR x: OPT.Node; y: OPT.Node); 
	PROCEDURE ^ NotVar(x: OPT.Node): BOOLEAN; 
	PROCEDURE ^ DeRef*(VAR x: OPT.Node); 
	PROCEDURE ^ Index*(VAR x: OPT.Node; y: OPT.Node); 
	PROCEDURE ^ Field*(VAR x: OPT.Node; y: OPT.Object); 
	PROCEDURE ^ TypTest*(VAR x: OPT.Node; obj: OPT.Object; guard: BOOLEAN); 
	PROCEDURE ^ In*(VAR x: OPT.Node; y: OPT.Node); 
	PROCEDURE ^ log(x: LONGINT): LONGINT; 
	PROCEDURE ^ CheckRealType(f, nr: INTEGER; x: OPT.Const); 
	PROCEDURE ^ MOp*(op: SHORTINT; VAR x: OPT.Node); 
	PROCEDURE ^ CheckPtr(VAR x, y: OPT.Node); 
	PROCEDURE ^ CheckParameters*(fp, ap: OPT.Object; checkNames: BOOLEAN); 
	PROCEDURE ^ CheckProc(x: OPT.Struct; y: OPT.Object); 
	PROCEDURE ^ ConstOp(op: INTEGER; x, y: OPT.Node); 
	PROCEDURE ^ Convert(VAR x: OPT.Node; typ: OPT.Struct); 
	PROCEDURE ^ Val(VAR x: OPT.Node; typ: OPT.Struct); 
	PROCEDURE ^ Op*(op: SHORTINT; VAR x: OPT.Node; y: OPT.Node); 
	PROCEDURE ^ SetRange*(VAR x: OPT.Node; y: OPT.Node); 
	PROCEDURE ^ SetElem*(VAR x: OPT.Node); 
	PROCEDURE ^ CheckAssign(x: OPT.Struct; ynode: OPT.Node); 
	PROCEDURE ^ CheckLeaf(x: OPT.Node; dynArrToo: BOOLEAN); 
	PROCEDURE ^ StPar0*(VAR par0: OPT.Node; fctno: INTEGER); 
	PROCEDURE ^ StPar1*(VAR par0: OPT.Node; x: OPT.Node; fctno: SHORTINT); 
	PROCEDURE ^ StParN*(VAR par0: OPT.Node; x: OPT.Node; fctno, n: INTEGER); 
	PROCEDURE ^ StFct*(VAR par0: OPT.Node; fctno: SHORTINT; parno: INTEGER); 
	PROCEDURE ^ OpenArrParCheck(ftyp, atyp: OPT.Struct; fvarpar: BOOLEAN); 
	PROCEDURE ^ CheckReceiver(VAR x: OPT.Node; fp: OPT.Object); 
	PROCEDURE ^ PrepCall*(VAR x: OPT.Node; VAR fpar: OPT.Object); 
	PROCEDURE ^ Param*(VAR ap: OPT.Node; fp: OPT.Object); 
	PROCEDURE ^ StaticLink*(dlev: LONGINT); 
	PROCEDURE ^ Call*(VAR x: OPT.Node; apar: OPT.Node; fp: OPT.Object); 
	PROCEDURE ^ CopyAndSubst*(VAR new: OPT.Node; old: OPT.Node); 
	PROCEDURE ^ Lock*(VAR x: OPT.Node; self: OPT.Object; excl: BOOLEAN); 
	PROCEDURE ^ Enter*(VAR procdec: OPT.Node; stat: OPT.Node; proc: OPT.Object); 
	PROCEDURE ^ Return*(VAR x: OPT.Node; proc: OPT.Object); 
	PROCEDURE ^ Assign*(VAR x: OPT.Node; y: OPT.Node); 
	PROCEDURE ^ Inittd*(VAR inittd, last: OPT.Node; typ: OPT.Struct); 
BEGIN
END OPB.
