MODULE FoxIntermediateBackend;
	IMPORT Basic := FoxBasic, SyntaxTree := FoxSyntaxTree, SemanticChecker := FoxSemanticChecker, Backend := FoxBackend, Global := FoxGlobal, Scanner := FoxScanner, IntermediateCode := FoxIntermediateCode, Sections := FoxSections, BinaryCode := FoxBinaryCode, Printout := FoxPrintout, SYSTEM, Diagnostics, Strings, Options, Streams, Compiler, Formats := FoxFormats, SymbolFileFormat := FoxTextualSymbolFile, D := Debugging, FingerPrinter := FoxFingerPrinter, StringPool, CRC;
CONST 
	ModeUndefined = 0; 
	ModeReference = 1; 
	ModeValue = 2; 
	ArrayDimTable = 3; 
	MathPtrOffset = 0; 
	MathAdrOffset = 1; 
	MathFlagsOffset = 2; 
	MathDimOffset = 3; 
	MathElementSizeOffset = 4; 
	MathLenOffset = 5; 
	MathIncrOffset = 6; 
	SysDataArrayOffset* = 0; 
	ArrDataArrayOffset* = (16 * 8); 
	TensorFlag* = 0; 
	RangeFlag* = 1; 
	StackFlag* = 2; 
	StaticFlag* = 1; 
	WithTrap* = 1; 
	CaseTrap* = 2; 
	ReturnTrap* = 3; 
	TypeEqualTrap* = 5; 
	TypeCheckTrap* = 6; 
	IndexCheckTrap* = 7; 
	AssertTrap* = 8; 
	ArraySizeTrap* = 9; 
	ArrayFormTrap* = 10; 
	SetElementTrap* = 11; 
	NegativeDivisorTrap* = 12; 
	NoReturnTrap* = 16; 
	NilPointerTrap* = 17; 
	RethrowTrap* = 18; 
	Trace = FALSE; 
	TraceRegisterUsageCount = TRUE; 
	ArrayAlignment = (8 * 8); 
	NumberSystemCalls* = 12; 
	SysNewRec* = 0; 
	SysNewArr* = 1; 
	SysNewSys* = 2; 
	SysCaseTable* = 3; 
	SysProcAddr* = 4; 
	SysLock* = 5; 
	SysUnlock* = 6; 
	SysStart* = 7; 
	SysAwait* = 8; 
	SysInterfaceLookup* = 9; 
	SysRegisterInterface* = 10; 
	SysGetProcedure* = 11; 
	DefaultRuntimeModuleName = \"Runtime"\; 
	DefaultTraceModuleName = \"KernelLog"\; 
	ChannelModuleName = \"Channels"\; 
	NonPointer =  -1; 
	NoType = 0; 
	LhsIsPointer = 0; 
	RhsIsPointer = 1; 
	EntryPriority =  -4; 
	FirstPriority =  -3; 
	InitPriority =  -2; 
	ExitPriority =  -1; 
	BasePointerTypeSize = 5; 
	BaseArrayTypeSize = (BasePointerTypeSize + 3); 
	LengthOffset = (BasePointerTypeSize + 0); 
	DataOffset = (BasePointerTypeSize + 1); 
	DescriptorOffset = (BasePointerTypeSize + 2); 
	BaseRecordTypeSize = (BasePointerTypeSize + 2); 
	ActionOffset = (BasePointerTypeSize + 0); 
	MonitorOffset = (BasePointerTypeSize + 1); 
	BaseObjectTypeSize = BaseRecordTypeSize; 
	ActionTypeSize = 3; 
	MonitorTypeSize = 7; 
	ProcessorOffset = (BaseObjectTypeSize + 1); 
	StackLimitOffset* = (BaseObjectTypeSize + 3); 
	QuantumOffset = (BaseObjectTypeSize + 4); 
	SmallMatrixFlag = 3; 
	SmallVectorFlag = 3; 
	Size2Flag = 4; 
	Size3Flag = 5; 
	Size4Flag = 6; 
	Size5Flag = 7; 
	Size6Flag = 8; 
	Size7Flag = 9; 
	Size8Flag = 10; 
	ReflectionSupport = TRUE; 
	ProtectModulesPointers = FALSE; 
	CreateProcedureDescInfo = TRUE; 
	WarningDynamicLoading = FALSE; 
	SysvABI = {SyntaxTree.CCallingConvention, SyntaxTree.DarwinCCallingConvention}; 
	SysvABIorWINAPI = {SyntaxTree.CCallingConvention, SyntaxTree.DarwinCCallingConvention, SyntaxTree.WinAPICallingConvention}; 
TYPE 
	Position = SyntaxTree.Position; 

	SupportedInstructionProcedure* = PROCEDURE {DELEGATE}(CONST instr: IntermediateCode.Instruction; VAR moduleName, procedureName: ARRAY OF CHAR):BOOLEAN; 

	SupportedImmediateProcedure* = PROCEDURE {DELEGATE}(CONST op: IntermediateCode.Operand):BOOLEAN; 

	Operand = RECORD 
		mode: SHORTINT; 
		op: IntermediateCode.Operand; 
		tag: IntermediateCode.Operand; 
		extra: IntermediateCode.Operand; 
		dimOffset: LONGINT; 
	END; 

	Fixup = POINTER TO RECORD 
		pc: LONGINT; 
		nextFixup: Fixup; 
	END; 

	WriteBackCall = POINTER TO RECORD 
		call: SyntaxTree.ProcedureCallDesignator; 
		next: WriteBackCall; 
	END; 

	Label = OBJECT 
	VAR 
		fixups: Fixup; 
		section: IntermediateCode.Section; 
		pc: LONGINT; 

		PROCEDURE ^  & InitLabel(section: IntermediateCode.Section); 
		PROCEDURE ^ Resolve(pc: LONGINT); 
		PROCEDURE ^ AddFixup(at: LONGINT); 
	END Label; 

	ConditionalBranch = PROCEDURE {DELEGATE}(label: Label; op1, op2: IntermediateCode.Operand); 

	DeclarationVisitor = OBJECT (SyntaxTree.Visitor)
	VAR 
		backend: IntermediateBackend; 
		implementationVisitor: ImplementationVisitor; 
		meta: MetaDataGenerator; 
		system: Global.System; 
		currentScope: SyntaxTree.Scope; 
		module: Sections.Module; 
		moduleSelf: SyntaxTree.Variable; 
		dump: BOOLEAN; 
		forceModuleBody: BOOLEAN; 
		addressType: IntermediateCode.Type; 

		PROCEDURE ^  & Init(system: Global.System; implementationVisitor: ImplementationVisitor; backend: IntermediateBackend; forceModuleBody, dump: BOOLEAN); 
		PROCEDURE ^ Error(position: Position; CONST s: ARRAY OF CHAR); 
		PROCEDURE ^ Type(x: SyntaxTree.Type); 
		PROCEDURE ^ VisitBasicType*(x: SyntaxTree.BasicType); 
		PROCEDURE ^ VisitCharacterType*(x: SyntaxTree.CharacterType); 
		PROCEDURE ^ VisitIntegerType*(x: SyntaxTree.IntegerType); 
		PROCEDURE ^ VisitFloatType*(x: SyntaxTree.FloatType); 
		PROCEDURE ^ VisitComplexType*(x: SyntaxTree.ComplexType); 
		PROCEDURE ^ VisitQualifiedType*(x: SyntaxTree.QualifiedType); 
		PROCEDURE ^ VisitStringType*(x: SyntaxTree.StringType); 
		PROCEDURE ^ VisitArrayRangeType(x: SyntaxTree.RangeType); 
		PROCEDURE ^ VisitArrayType*(x: SyntaxTree.ArrayType); 
		PROCEDURE ^ VisitPortType*(x: SyntaxTree.PortType); 
		PROCEDURE ^ VisitMathArrayType*(x: SyntaxTree.MathArrayType); 
		PROCEDURE ^ VisitPointerType*(x: SyntaxTree.PointerType); 
		PROCEDURE ^ VisitRecordType*(x: SyntaxTree.RecordType); 
		PROCEDURE ^ HasFlag(modifiers: SyntaxTree.Modifier; CONST name: ARRAY OF CHAR): BOOLEAN; 
		PROCEDURE ^ VisitCellType*(x: SyntaxTree.CellType); 
		PROCEDURE ^ VisitProcedureType*(x: SyntaxTree.ProcedureType); 
		PROCEDURE ^ VisitEnumerationType*(x: SyntaxTree.EnumerationType); 
		PROCEDURE ^ VisitProcedure*(x: SyntaxTree.Procedure); 
		PROCEDURE ^ VisitOperator*(x: SyntaxTree.Operator); 
		PROCEDURE ^ VisitVariable*(x: SyntaxTree.Variable); 
		PROCEDURE ^ VisitProperty*(x: SyntaxTree.Property); 
		PROCEDURE ^ VisitParameter*(x: SyntaxTree.Parameter); 
		PROCEDURE ^ VisitTypeDeclaration*(x: SyntaxTree.TypeDeclaration); 
		PROCEDURE ^ VisitConstant*(x: SyntaxTree.Constant); 
		PROCEDURE ^ Scope(x: SyntaxTree.Scope); 
		PROCEDURE ^ Parameters(first: SyntaxTree.Parameter); 
		PROCEDURE ^ Procedure(x: SyntaxTree.Procedure); 
		PROCEDURE ^ AddBodyCallStub(bodyProcedure: SyntaxTree.Procedure); 
		PROCEDURE ^ AddStackAllocation(symbol: SyntaxTree.Symbol; initStack: Basic.Integer); 
		PROCEDURE ^ Module(x: SyntaxTree.Module; module: Sections.Module); 
	END DeclarationVisitor; 

	UsedArray* = POINTER TO ARRAY OF RECORD 
		count: LONGINT; 
		map: LONGINT; 
		type: IntermediateCode.Type; 
		class: IntermediateCode.RegisterClass; 
	END; 

	RegisterUsageCount* = OBJECT 
	VAR 
		used: UsedArray; 
		count: LONGINT; 

		PROCEDURE ^  & Init; 
		PROCEDURE ^ Grow; 
		PROCEDURE ^ Next(type: IntermediateCode.Type; class: IntermediateCode.RegisterClass): LONGINT; 
		PROCEDURE ^ IncUse(register: LONGINT); 
		PROCEDURE ^ DecUse(register: LONGINT); 
		PROCEDURE ^ Map(register: LONGINT): LONGINT; 
		PROCEDURE ^ Use(register: LONGINT): LONGINT; 
	END RegisterUsageCount; 

	RegisterEntry = POINTER TO RECORD 
		prev, next: RegisterEntry; 
		register: LONGINT; 
		registerClass: IntermediateCode.RegisterClass; 
		type: IntermediateCode.Type; 
	END; 

	VariableUse = ARRAY 32 OF SET; 

	Variables = OBJECT (Basic.List)
	VAR 
		inUse: VariableUse; 
		registerIndex: LONGINT; 
		nameIndex: LONGINT; 

		PROCEDURE ^  & Init; 
		PROCEDURE ^ Clear*; 
		PROCEDURE ^ GetUID(): SyntaxTree.Identifier; 
		PROCEDURE ^ GetUsage(VAR use: VariableUse); 
		PROCEDURE ^ SetUsage(CONST use: VariableUse); 
		PROCEDURE ^ GetVariable(i: LONGINT): SyntaxTree.Variable; 
		PROCEDURE ^ SetVariable(pos: LONGINT; v: SyntaxTree.Variable); 
		PROCEDURE ^ Occupy(pos: LONGINT); 
		PROCEDURE ^ Occupied(pos: LONGINT): BOOLEAN; 
		PROCEDURE ^ AddVariable(v: SyntaxTree.Variable); 
		PROCEDURE ^ CompatibleType(t1, t2: SyntaxTree.Type): BOOLEAN; 
		PROCEDURE ^ GetFreeVariable(type: SyntaxTree.Type; untraced: BOOLEAN; VAR pos: LONGINT): SyntaxTree.Variable; 
	END Variables; 

	SymbolMap = POINTER TO RECORD 
		this: SyntaxTree.Symbol; 
		to, tag: SyntaxTree.Expression; 
		next: SymbolMap; 
		isAddress: BOOLEAN; 
	END; 

	SymbolMapper = OBJECT 
	VAR 
		first: SymbolMap; 

		PROCEDURE ^  & Init; 
		PROCEDURE ^ Add(this: SyntaxTree.Symbol; to, tag: SyntaxTree.Expression; isAddress: BOOLEAN); 
		PROCEDURE ^ Get(this: SyntaxTree.Symbol): SymbolMap; 
	END SymbolMapper; 

	ImplementationVisitor = OBJECT (SyntaxTree.Visitor)
	TYPE 
		Context = RECORD 
			section: IntermediateCode.Section; 
			registerUsageCount: RegisterUsageCount; 
			usedRegisters: RegisterEntry; 
			temporaries: Variables; 
		END; 
	VAR 
		system: Global.System; 
		section: IntermediateCode.Section; 
		module: Sections.Module; 
		moduleScope: SyntaxTree.ModuleScope; 
		awaitProcCounter, labelId, constId, caseId: LONGINT; 
		hiddenPointerType: SyntaxTree.RecordType; 
		delegatePointerType: SyntaxTree.RecordType; 
		checker: SemanticChecker.Checker; 
		backend: IntermediateBackend; 
		meta: MetaDataGenerator; 
		position: Position; 
		moduleSelf: SyntaxTree.Variable; 
		currentScope: SyntaxTree.Scope; 
		constantDeclaration: SyntaxTree.Symbol; 
		result: Operand; 
		destination: IntermediateCode.Operand; 
		arrayDestinationTag: IntermediateCode.Operand; 
		arrayDestinationDimension: LONGINT; 
		currentLoop: Label; 
		conditional: BOOLEAN; 
		trueLabel, falseLabel, exitLabel: Label; 
		locked: BOOLEAN; 
		registerUsageCount: RegisterUsageCount; 
		usedRegisters: RegisterEntry; 
		nil, one, fp, sp, ap, lr, true, false: IntermediateCode.Operand; 
		bool, addressType, setType, sizeType, lenType, byteType: IntermediateCode.Type; 
		commentPrintout: Printout.Printer; 
		dump: Streams.Writer; 
		tagsAvailable: BOOLEAN; 
		supportedInstruction: SupportedInstructionProcedure; 
		supportedImmediate: SupportedImmediateProcedure; 
		inData: BOOLEAN; 
		emitLabels: BOOLEAN; 
		runtimeModuleName: SyntaxTree.IdentifierString; 
		newObjectFile: BOOLEAN; 
		indexCounter: LONGINT; 
		profile: BOOLEAN; 
		profileId, profileInit: IntermediateCode.Section; 
		profileInitPatchPosition: LONGINT; 
		numberProcedures: LONGINT; 
		procedureResultDesignator: SyntaxTree.Designator; 
		operatorInitializationCodeSection: IntermediateCode.Section; 
		fingerPrinter: FingerPrinter.FingerPrinter; 
		temporaries: Variables; 
		canBeLoaded: BOOLEAN; 
		currentIsInline: BOOLEAN; 
		currentMapper: SymbolMapper; 
		currentInlineExit: Label; 
		moduleBodySection: IntermediateCode.Section; 
		NeedDescriptor: BOOLEAN; 
		cooperativeSwitches: BOOLEAN; 
		lastSwitchPC: LONGINT; 
		isUnchecked: BOOLEAN; 
		modifyAssignmentCounter: LONGINT; 

		PROCEDURE ^  & Init(system: Global.System; checker: SemanticChecker.Checker; supportedInstructionProcedure: SupportedInstructionProcedure; supportedImmediateProcedure: SupportedImmediateProcedure; emitLabels: BOOLEAN; CONST runtime: SyntaxTree.IdentifierString; backend: IntermediateBackend; newObjectFile: BOOLEAN); 
		PROCEDURE ^ SwitchContext(new: IntermediateCode.Section): Context; 
		PROCEDURE ^ ReturnToContext(context: Context); 
		PROCEDURE ^ NewSection(list: Sections.SectionList; type: SHORTINT; CONST name: Basic.SegmentedName; syntaxTreeSymbol: SyntaxTree.Symbol; dump: BOOLEAN): IntermediateCode.Section; 
		PROCEDURE ^ AcquireRegister(CONST type: IntermediateCode.Type; class: IntermediateCode.RegisterClass): LONGINT; 
		PROCEDURE ^ GetFingerprintString(symbol: SyntaxTree.Symbol; VAR string: ARRAY OF CHAR); 
		PROCEDURE ^ GetCodeSectionNameForSymbol(symbol: SyntaxTree.Symbol; VAR name: Basic.SegmentedName); 
		PROCEDURE ^ GetCodeSectionNameForSymbolInScope(symbol: SyntaxTree.Symbol; scope: SyntaxTree.Scope; VAR name: ARRAY OF CHAR); 
		PROCEDURE ^ TraceEnter(CONST s: ARRAY OF CHAR); 
		PROCEDURE ^ TraceExit(CONST s: ARRAY OF CHAR); 
		PROCEDURE ^ Emit(instruction: IntermediateCode.Instruction); 
		PROCEDURE ^ EmitTrap(position: Position; trapNo: LONGINT); 
		PROCEDURE ^ EmitEnter(section: IntermediateCode.Section; position: Position; procedure: SyntaxTree.Procedure; callconv: LONGINT; varSize: LONGINT; numRegs: LONGINT); 
		PROCEDURE ^ Enter(position: Position; callconv: LONGINT; varSize: LONGINT): IntermediateCode.Instruction; 
		PROCEDURE ^ Leave(position: Position; callconv: LONGINT): IntermediateCode.Instruction; 
		PROCEDURE ^ EmitLeave(section: IntermediateCode.Section; position: Basic.Position; procedure: SyntaxTree.Procedure; callconv: LONGINT); 
		PROCEDURE ^ Symbol(x: SyntaxTree.Symbol; VAR op: Operand); 
		PROCEDURE ^ Expression(x: SyntaxTree.Expression); 
		PROCEDURE ^ Statement(x: SyntaxTree.Statement); 
		PROCEDURE ^ MakeMemory(VAR res: IntermediateCode.Operand; op: IntermediateCode.Operand; type: IntermediateCode.Type; offset: LONGINT); 
		PROCEDURE ^ ToMemory(VAR res: IntermediateCode.Operand; type: IntermediateCode.Type; offset: LONGINT); 
		PROCEDURE ^ LoadValue(VAR operand: Operand; type: SyntaxTree.Type); 
		PROCEDURE ^ Evaluate(x: SyntaxTree.Expression; VAR op: Operand); 
		PROCEDURE ^ Designate(x: SyntaxTree.Expression; VAR op: Operand); 
		PROCEDURE ^ Condition(x: SyntaxTree.Expression; trueL, falseL: Label); 
		PROCEDURE ^ NewRegisterOperand(type: IntermediateCode.Type): IntermediateCode.Operand; 
		PROCEDURE ^ UnuseRegister(register: LONGINT); 
		PROCEDURE ^ UseRegister(register: LONGINT); 
		PROCEDURE ^ ReleaseIntermediateOperand(CONST op: IntermediateCode.Operand); 
		PROCEDURE ^ UseIntermediateOperand(CONST op: IntermediateCode.Operand); 
		PROCEDURE ^ ReleaseOperand(CONST op: Operand); 
		PROCEDURE ^ SaveRegisters; 
		PROCEDURE ^ ReleaseUsedRegisters(VAR saved: RegisterEntry); 
		PROCEDURE ^ ReleaseParameterRegisters; 
		PROCEDURE ^ RestoreRegisters(CONST saved: RegisterEntry); 
		PROCEDURE ^ CheckRegistersFree; 
		PROCEDURE ^ Reuse2(VAR result: IntermediateCode.Operand; src1, src2: IntermediateCode.Operand); 
		PROCEDURE ^ Reuse2a(VAR result: IntermediateCode.Operand; src1, src2: IntermediateCode.Operand; VAR alternative: IntermediateCode.Operand); 
		PROCEDURE ^ Reuse1(VAR result: IntermediateCode.Operand; src1: IntermediateCode.Operand); 
		PROCEDURE ^ Reuse1a(VAR result: IntermediateCode.Operand; src1: IntermediateCode.Operand; VAR alternative: IntermediateCode.Operand); 
		PROCEDURE ^ ReuseCopy(VAR result: IntermediateCode.Operand; src1: IntermediateCode.Operand); 
		PROCEDURE ^ TransferToRegister(VAR result: IntermediateCode.Operand; src: IntermediateCode.Operand); 
		PROCEDURE ^ NewLabel(): Label; 
		PROCEDURE ^ SetLabel(label: Label); 
		PROCEDURE ^ LabelOperand(label: Label): IntermediateCode.Operand; 
		PROCEDURE ^ BrL(label: Label); 
		PROCEDURE ^ BrgeL(label: Label; left, right: IntermediateCode.Operand); 
		PROCEDURE ^ BrltL(label: Label; left, right: IntermediateCode.Operand); 
		PROCEDURE ^ BreqL(label: Label; left, right: IntermediateCode.Operand); 
		PROCEDURE ^ BrneL(label: Label; left, right: IntermediateCode.Operand); 
		PROCEDURE ^ Convert(VAR operand: IntermediateCode.Operand; type: IntermediateCode.Type); 
		PROCEDURE ^ TrapC(br: ConditionalBranch; left, right: IntermediateCode.Operand; trapNo: LONGINT); 
		PROCEDURE ^ CheckSetElement(o: IntermediateCode.Operand); 
		PROCEDURE ^ SetFromRange(x: SyntaxTree.RangeExpression): IntermediateCode.Operand; 
		PROCEDURE ^ VisitSet*(x: SyntaxTree.Set); 
		PROCEDURE ^ VisitMathArrayExpression*(x: SyntaxTree.MathArrayExpression); 
		PROCEDURE ^ VisitUnaryExpression*(x: SyntaxTree.UnaryExpression); 
		PROCEDURE ^ TypeTest(tag: IntermediateCode.Operand; type: SyntaxTree.Type; trueL, falseL: Label); 
		PROCEDURE ^ Error(position: Position; CONST s: ARRAY OF CHAR); 
		PROCEDURE ^ Warning(position: Position; CONST s: ARRAY OF CHAR); 
		PROCEDURE ^ CreateTraceModuleMethod(mod: SyntaxTree.Module); 
		PROCEDURE ^ CallAssignPointer(CONST dst, src: IntermediateCode.Operand); 
		PROCEDURE ^ CallAssignMethod(CONST dst, src: IntermediateCode.Operand; type: SyntaxTree.Type); 
		PROCEDURE ^ CreateAssignProcedure(recordType: SyntaxTree.RecordType); 
		PROCEDURE ^ CallTraceMethod(CONST register: IntermediateCode.Operand; type: SyntaxTree.Type); 
		PROCEDURE ^ CreateTraceMethod(recordType: SyntaxTree.RecordType); 
		PROCEDURE ^ CreateResetProcedure(recordType: SyntaxTree.RecordType); 
		PROCEDURE ^ CreateResetMethod(scope: SyntaxTree.ProcedureScope); 
		PROCEDURE ^ CallResetProcedure(dest, tag: IntermediateCode.Operand; type: SyntaxTree.Type); 
		PROCEDURE ^ ResetVariables(scope: SyntaxTree.ProcedureScope); 
		PROCEDURE ^ CreateProcedureDescriptor(procedure: SyntaxTree.Procedure); 
		PROCEDURE ^ AddImport(CONST moduleName: ARRAY OF CHAR; VAR module: SyntaxTree.Module; force: BOOLEAN): BOOLEAN; 
		PROCEDURE ^ EnsureSymbol(CONST moduleName, procedureName: SyntaxTree.IdentifierString); 
		PROCEDURE ^ ConditionToValue(x: SyntaxTree.Expression); 
		PROCEDURE ^ ValueToCondition(VAR op: Operand); 
		PROCEDURE ^ GetDynamicSize(type: SyntaxTree.Type; tag: IntermediateCode.Operand): IntermediateCode.Operand; 
		PROCEDURE ^ GetArrayLength(type: SyntaxTree.Type; tag: IntermediateCode.Operand): IntermediateCode.Operand; 
		PROCEDURE ^ GetSizeFromTag(tag: IntermediateCode.Operand): IntermediateCode.Operand; 
		PROCEDURE ^ GetArrayOfBytesSize(e: SyntaxTree.Expression; tag: IntermediateCode.Operand): IntermediateCode.Operand; 
		PROCEDURE ^ GetRuntimeProcedure(CONST moduleName, procedureName: ARRAY OF CHAR; VAR procedure: SyntaxTree.Procedure; force: BOOLEAN): BOOLEAN; 
		PROCEDURE ^ GetTypeDescriptor(CONST moduleName, typeName: ARRAY OF CHAR; VAR name: Basic.SegmentedName): SyntaxTree.Symbol; 
		PROCEDURE ^ CallThisChecked(position: Position; CONST moduleName, procedureName: ARRAY OF CHAR; numberParameters: LONGINT; checkNumParameters: BOOLEAN); 
		PROCEDURE ^ CallThis(position: Position; CONST moduleName, procedureName: ARRAY OF CHAR; numberParameters: LONGINT); 
		PROCEDURE ^ CompareString(br: ConditionalBranch; leftExpression, rightExpression: SyntaxTree.Expression); 
		PROCEDURE ^ CopyString(leftExpression, rightExpression: SyntaxTree.Expression); 
		PROCEDURE ^ VisitBinaryExpression*(x: SyntaxTree.BinaryExpression); 
		PROCEDURE ^ VisitRangeExpression*(x: SyntaxTree.RangeExpression); 
		PROCEDURE ^ VisitTensorRangeExpression*(x: SyntaxTree.TensorRangeExpression); 
		PROCEDURE ^ VisitConversion*(x: SyntaxTree.Conversion); 
		PROCEDURE ^ VisitTypeDeclaration*(x: SyntaxTree.TypeDeclaration); 
		PROCEDURE ^ VisitSymbolDesignator*(x: SyntaxTree.SymbolDesignator); 
		PROCEDURE ^ BoundCheck(index, length: IntermediateCode.Operand); 
		PROCEDURE ^ DimensionCheck(base, dim: IntermediateCode.Operand; op: ConditionalBranch); 
		PROCEDURE ^ MathIndexDesignator(x: SyntaxTree.IndexDesignator); 
		PROCEDURE ^ ArrayLength(type: SyntaxTree.Type; dim: LONGINT; tag: IntermediateCode.Operand): IntermediateCode.Operand; 
		PROCEDURE ^ CopyInt(VAR res: IntermediateCode.Operand; x: IntermediateCode.Operand); 
		PROCEDURE ^ AddInt(VAR res: IntermediateCode.Operand; x, y: IntermediateCode.Operand); 
		PROCEDURE ^ MulInt(VAR res: IntermediateCode.Operand; x, y: IntermediateCode.Operand); 
		PROCEDURE ^ DivInt(VAR res: IntermediateCode.Operand; x, y: IntermediateCode.Operand); 
		PROCEDURE ^ IndexDesignator(x: SyntaxTree.IndexDesignator); 
		PROCEDURE ^ VisitIndexDesignator*(x: SyntaxTree.IndexDesignator); 
		PROCEDURE ^ PrepareTensorDescriptor(expression: SyntaxTree.IndexDesignator): SyntaxTree.Variable; 
		PROCEDURE ^ PushParameter(expression: SyntaxTree.Expression; parameter: SyntaxTree.Parameter; callingConvention: LONGINT; needsParameterBackup: BOOLEAN; VAR parameterBackup: IntermediateCode.Operand; numberRegister: LONGINT); 
		PROCEDURE ^ VisitStatementDesignator*(x: SyntaxTree.StatementDesignator); 
		PROCEDURE ^ InlineProcedureCall(x: SyntaxTree.ProcedureCallDesignator): BOOLEAN; 
		PROCEDURE ^ VisitProcedureCallDesignator*(x: SyntaxTree.ProcedureCallDesignator); 
		PROCEDURE ^ TypeDescriptorAdr(t: SyntaxTree.Type): IntermediateCode.Operand; 
		PROCEDURE ^ ProfilerInit; 
		PROCEDURE ^ ProfilerEnterExit(procedureNumber: LONGINT; enter: BOOLEAN); 
		PROCEDURE ^ ProfilerAddProcedure(procedureNumber: LONGINT; CONST name: ARRAY OF CHAR); 
		PROCEDURE ^ ProfilerAddModule(CONST name: ARRAY OF CHAR); 
		PROCEDURE ^ ProfilerPatchInit; 
		PROCEDURE ^ RegisterDynamicOperator(operator: SyntaxTree.Operator); 
		PROCEDURE ^ SystemTrace(x: SyntaxTree.ExpressionList; pos: Position); 
		PROCEDURE ^ InitFields(type: SyntaxTree.Type; CONST adr: IntermediateCode.Operand; offset: LONGINT); 
		PROCEDURE ^ InitVariable(VAR variable: SyntaxTree.Variable; temporary: BOOLEAN); 
		PROCEDURE ^ MathArrayDim(type: SyntaxTree.MathArrayType; CONST base: IntermediateCode.Operand; VAR result: Operand); 
		PROCEDURE ^ PutMathArrayField(base, value: IntermediateCode.Operand; fieldOffset: LONGINT); 
		PROCEDURE ^ PutMathArrayFieldOffset(base, value: IntermediateCode.Operand; fieldOffset, offset: LONGINT); 
		PROCEDURE ^ GetMathArrayField(VAR value: IntermediateCode.Operand; base: IntermediateCode.Operand; offset: LONGINT); 
		PROCEDURE ^ PutMathArrayLenOrIncr(CONST base, value, dim: IntermediateCode.Operand; incr: BOOLEAN); 
		PROCEDURE ^ PutMathArrayLength(base, value: IntermediateCode.Operand; dim: LONGINT); 
		PROCEDURE ^ PutMathArrayIncrement(base, value: IntermediateCode.Operand; dim: LONGINT); 
		PROCEDURE ^ GetMathArrayIncrement(type: SyntaxTree.MathArrayType; CONST operand: Operand; VAR dim: IntermediateCode.Operand; check: BOOLEAN; VAR result: Operand); 
		PROCEDURE ^ GetMathArrayLength(type: SyntaxTree.MathArrayType; CONST operand: Operand; VAR dim: IntermediateCode.Operand; check: BOOLEAN; VAR result: Operand); 
		PROCEDURE ^ GetMathArrayLengthAt(type: SyntaxTree.MathArrayType; CONST operand: Operand; dim: LONGINT; check: BOOLEAN; VAR result: Operand); 
		PROCEDURE ^ GetMathArrayIncrementAt(type: SyntaxTree.MathArrayType; CONST operand: Operand; dim: LONGINT; check: BOOLEAN; VAR result: Operand); 
		PROCEDURE ^ MathArrayLenOrIncr(type: SyntaxTree.MathArrayType; CONST operand: Operand; VAR dim: IntermediateCode.Operand; increment: BOOLEAN; check: BOOLEAN; VAR result: Operand); 
		PROCEDURE ^ ArrayLen(type: SyntaxTree.ArrayType; VAR operand: Operand; VAR dim: IntermediateCode.Operand; VAR result: Operand); 
		PROCEDURE ^ GetTemporaryVariable(type: SyntaxTree.Type; register: BOOLEAN; untraced: BOOLEAN): SyntaxTree.Variable; 
		PROCEDURE ^ GetMathArrayDescriptorType(dimensions: LONGINT): SyntaxTree.Type; 
		PROCEDURE ^ NewMathArrayDescriptor(op: Operand; dimensions: LONGINT); 
		PROCEDURE ^ PushConstString(CONST s: ARRAY OF CHAR); 
		PROCEDURE ^ PushConstBoolean(b: BOOLEAN); 
		PROCEDURE ^ PushConstSet(v: SET); 
		PROCEDURE ^ PushConstInteger(v: LONGINT); 
		PROCEDURE ^ OpenInitializer(symbol: SyntaxTree.Symbol; scope: SyntaxTree.Scope): IntermediateCode.Section; 
		PROCEDURE ^ CloseInitializer(prev: IntermediateCode.Section); 
		PROCEDURE ^ AddPorts(cell: SyntaxTree.Symbol; x: SyntaxTree.CellType); 
		PROCEDURE ^ AddProperty(cellType: SyntaxTree.CellType; cell: SyntaxTree.Symbol; property: SyntaxTree.Property; value: SyntaxTree.Expression); 
		PROCEDURE ^ AddModifiers(cellType: SyntaxTree.CellType; cell: SyntaxTree.Symbol; modifier: SyntaxTree.Modifier); 
		PROCEDURE ^ AppendModifier(VAR to: SyntaxTree.Modifier; this: SyntaxTree.Modifier); 
		PROCEDURE ^ AppendModifiers(VAR to: SyntaxTree.Modifier; this: SyntaxTree.Modifier); 
		PROCEDURE ^ AppendCellTypeModifiers(VAR to: SyntaxTree.Modifier; c: SyntaxTree.CellType); 
		PROCEDURE ^ AddPortProperty(modifier: SyntaxTree.Modifier; value: SyntaxTree.Expression); 
		PROCEDURE ^ AddPortProperties(modifier: SyntaxTree.Modifier); 
		PROCEDURE ^ PushPort(p: SyntaxTree.Expression); 
		PROCEDURE ^ PushString(op: Operand; actualType: SyntaxTree.Type); 
		PROCEDURE ^ OnHeap(x: SyntaxTree.Expression): BOOLEAN; 
		PROCEDURE ^ VisitBuiltinCallDesignator*(x: SyntaxTree.BuiltinCallDesignator); 
		PROCEDURE ^ VisitTypeGuardDesignator*(x: SyntaxTree.TypeGuardDesignator); 
		PROCEDURE ^ Dereference(VAR operand: Operand; type: SyntaxTree.Type; isUnsafe: BOOLEAN); 
		PROCEDURE ^ VisitDereferenceDesignator*(x: SyntaxTree.DereferenceDesignator); 
		PROCEDURE ^ VisitSupercallDesignator*(x: SyntaxTree.SupercallDesignator); 
		PROCEDURE ^ VisitSelfDesignator*(x: SyntaxTree.SelfDesignator); 
		PROCEDURE ^ VisitResultDesignator*(x: SyntaxTree.ResultDesignator); 
		PROCEDURE ^ VisitBooleanValue*(x: SyntaxTree.BooleanValue); 
		PROCEDURE ^ GetDataSection*(): IntermediateCode.Section; 
		PROCEDURE ^ GetImmediateMem(VAR vop: IntermediateCode.Operand); 
		PROCEDURE ^ VisitIntegerValue*(x: SyntaxTree.IntegerValue); 
		PROCEDURE ^ VisitCharacterValue*(x: SyntaxTree.CharacterValue); 
		PROCEDURE ^ VisitSetValue*(x: SyntaxTree.SetValue); 
		PROCEDURE ^ VisitMathArrayValue*(x: SyntaxTree.MathArrayValue); 
		PROCEDURE ^ TryConstantDeclaration(): BOOLEAN; 
		PROCEDURE ^ VisitConstant*(x: SyntaxTree.Constant); 
		PROCEDURE ^ VisitRealValue*(x: SyntaxTree.RealValue); 
		PROCEDURE ^ VisitComplexValue*(x: SyntaxTree.ComplexValue); 
		PROCEDURE ^ VisitStringValue*(x: SyntaxTree.StringValue); 
		PROCEDURE ^ VisitNilValue*(x: SyntaxTree.NilValue); 
		PROCEDURE ^ VisitEnumerationValue*(x: SyntaxTree.EnumerationValue); 
		PROCEDURE ^ VisitImport*(x: SyntaxTree.Import); 
		PROCEDURE ^ GetBaseRegister(VAR result: IntermediateCode.Operand; scope, baseScope: SyntaxTree.Scope); 
		PROCEDURE ^ VisitVariable*(x: SyntaxTree.Variable); 
		PROCEDURE ^ VisitProperty*(property: SyntaxTree.Property); 
		PROCEDURE ^ VisitParameter*(x: SyntaxTree.Parameter); 
		PROCEDURE ^ DynamicCallOperand(VAR operand: Operand; x: SyntaxTree.Procedure); 
		PROCEDURE ^ StaticCallOperand(VAR operand: Operand; x: SyntaxTree.Procedure); 
		PROCEDURE ^ VisitProcedure*(x: SyntaxTree.Procedure); 
		PROCEDURE ^ VisitOperator*(x: SyntaxTree.Operator); 
		PROCEDURE ^ VisitProcedureCallStatement*(x: SyntaxTree.ProcedureCallStatement); 
		PROCEDURE ^ AssignMathArray(left, right: SyntaxTree.Expression); 
		PROCEDURE ^ ModifyAssignments(CONST value: IntermediateCode.Operand); 
		PROCEDURE ^ CopySize(left: SyntaxTree.Expression; tag: IntermediateCode.Operand): IntermediateCode.Operand; 
		PROCEDURE ^ Assign(left, right: SyntaxTree.Expression); 
		PROCEDURE ^ VisitAssignment*(x: SyntaxTree.Assignment); 
		PROCEDURE ^ EmitCooperativeSwitch; 
		PROCEDURE ^ VisitCommunicationStatement*(communication: SyntaxTree.CommunicationStatement); 
		PROCEDURE ^ VisitIfStatement*(x: SyntaxTree.IfStatement); 
		PROCEDURE ^ WithPart(x: SyntaxTree.WithPart; VAR falseL, endL: Label); 
		PROCEDURE ^ VisitWithStatement*(x: SyntaxTree.WithStatement); 
		PROCEDURE ^ VisitCaseStatement*(x: SyntaxTree.CaseStatement); 
		PROCEDURE ^ VisitWhileStatement*(x: SyntaxTree.WhileStatement); 
		PROCEDURE ^ VisitRepeatStatement*(x: SyntaxTree.RepeatStatement); 
		PROCEDURE ^ VisitForStatement*(x: SyntaxTree.ForStatement); 
		PROCEDURE ^ VisitExitableBlock*(x: SyntaxTree.ExitableBlock); 
		PROCEDURE ^ VisitLoopStatement*(x: SyntaxTree.LoopStatement); 
		PROCEDURE ^ VisitExitStatement*(x: SyntaxTree.ExitStatement); 
		PROCEDURE ^ VisitReturnStatement*(x: SyntaxTree.ReturnStatement); 
		PROCEDURE ^ MakeAwaitProcedure(x: SyntaxTree.AwaitStatement): SyntaxTree.Procedure; 
		PROCEDURE ^ VisitAwaitStatement*(x: SyntaxTree.AwaitStatement); 
		PROCEDURE ^ StatementSequence(x: SyntaxTree.StatementSequence); 
		PROCEDURE ^ PushSelfPointer; 
		PROCEDURE ^ Lock(lock: BOOLEAN); 
		PROCEDURE ^ VisitStatementBlock*(x: SyntaxTree.StatementBlock); 
		PROCEDURE ^ VisitCode*(x: SyntaxTree.Code); 
		PROCEDURE ^ ProcParametersSize(procedure: SyntaxTree.Procedure): LONGINT; 
		PROCEDURE ^ ParameterCopies(x: SyntaxTree.ProcedureType); 
		PROCEDURE ^ InitVariables(scope: SyntaxTree.Scope); 
		PROCEDURE ^ GetFingerprint(symbol: SyntaxTree.Symbol): LONGINT; 
		PROCEDURE ^ Body(x: SyntaxTree.Body; scope: SyntaxTree.Scope; ir: IntermediateCode.Section; moduleBody: BOOLEAN); 
	END ImplementationVisitor; 

	MetaDataGenerator = OBJECT 
	CONST 
		EmptyBlockOffset = 2; 
	VAR 
		implementationVisitor: ImplementationVisitor; 
		declarationVisitor: DeclarationVisitor; 
		module: Sections.Module; 
		moduleName: ARRAY 128 OF CHAR; 
		moduleNamePool: Basic.HashTableInt; 
		moduleNamePoolSection: IntermediateCode.Section; 
		modulePointerSection: IntermediateCode.Section; 
		modulePointerSizePC: LONGINT; 
		modulePointerSectionOffset: LONGINT; 
		modulePointers: LONGINT; 
		simple: BOOLEAN; 
		RecordBaseOffset: LONGINT; 
		MethodTableOffset: LONGINT; 
		BaseTypesTableOffset: LONGINT; 
		TypeTags: LONGINT; 
		TypeRecordBaseOffset: LONGINT; 
		patchInfoPC: LONGINT; 
		patchCRC: LONGINT; 

		PROCEDURE ^  & InitMetaDataGenerator(implementationVisitor: ImplementationVisitor; declarationVisitor: DeclarationVisitor; simple: BOOLEAN); 
		PROCEDURE ^ SetModule(module: Sections.Module); 
		PROCEDURE ^ AddPointer(section: IntermediateCode.Section; offset: LONGINT); 
		PROCEDURE ^ GetTypeRecordBaseOffset(numberMethods: LONGINT): LONGINT; 
		PROCEDURE ^ HeapBlock(CONST moduleName, typeName: ARRAY OF CHAR; section: IntermediateCode.Section; dataAdrOffset: LONGINT); 
		PROCEDURE ^ ProtectedHeapBlock(CONST moduleName, typeName: ARRAY OF CHAR; section: IntermediateCode.Section; dataAdrOffset: LONGINT); 
		PROCEDURE ^ Info(section: IntermediateCode.Section; CONST s: ARRAY OF CHAR); 
		PROCEDURE ^ Address(section: IntermediateCode.Section; value: ADDRESS); 
		PROCEDURE ^ Size(section: IntermediateCode.Section; value: SIZE); 
		PROCEDURE ^ Set(section: IntermediateCode.Section; value: Basic.Set); 
		PROCEDURE ^ Longint(section: IntermediateCode.Section; value: LONGINT); 
		PROCEDURE ^ PatchAddress(section: IntermediateCode.Section; pc: LONGINT; value: LONGINT); 
		PROCEDURE ^ PatchSize(section: IntermediateCode.Section; pc: LONGINT; value: LONGINT); 
		PROCEDURE ^ PatchLongint(section: IntermediateCode.Section; pc: LONGINT; value: LONGINT); 
		PROCEDURE ^ PatchSymbol(section: IntermediateCode.Section; pc: LONGINT; name: Basic.SegmentedName; symbol: SyntaxTree.Symbol; virtualOffset, realOffset: LONGINT); 
		PROCEDURE ^ Boolean(section: IntermediateCode.Section; value: BOOLEAN); 
		PROCEDURE ^ Char(section: IntermediateCode.Section; char: CHAR); 
		PROCEDURE ^ Integer(section: IntermediateCode.Section; int: LONGINT); 
		PROCEDURE ^ String(section: IntermediateCode.Section; CONST str: ARRAY OF CHAR); 
		PROCEDURE ^ String0(section: IntermediateCode.Section; str: StringPool.Index); 
		PROCEDURE ^ NamedSymbol(section: IntermediateCode.Section; name: Basic.SegmentedName; symbol: SyntaxTree.Symbol; virtualOffset, realOffset: LONGINT); 
		PROCEDURE ^ NamedSymbolAt(section: IntermediateCode.Section; pc: LONGINT; name: Basic.SegmentedName; symbol: SyntaxTree.Symbol; virtualOffset, realOffset: LONGINT); 
		PROCEDURE ^ Symbol(section: IntermediateCode.Section; symbol: Sections.Section; virtualOffset, realOffset: LONGINT); 
		PROCEDURE ^ Pointers(offset: LONGINT; symbol: Sections.Section; section: IntermediateCode.Section; type: SyntaxTree.Type; VAR numberPointers: LONGINT); 
		PROCEDURE ^ EnterDynamicName(source: IntermediateCode.Section; CONST name: ARRAY OF CHAR; index: LONGINT; pool: Basic.HashTableInt): LONGINT; 
		PROCEDURE ^ DynamicName(source: IntermediateCode.Section; index: StringPool.Index; pool: Basic.HashTableInt): LONGINT; 
		PROCEDURE ^ NamedBlock(CONST mName, typeName: ARRAY OF CHAR; name: Basic.SegmentedName; VAR offset: LONGINT): IntermediateCode.Section; 
		PROCEDURE ^ Block(CONST mName, typeName, suffix: ARRAY OF CHAR; VAR offset: LONGINT): IntermediateCode.Section; 
		PROCEDURE ^ ArrayBlock(source: IntermediateCode.Section; VAR sizePC: LONGINT; CONST baseType: ARRAY OF CHAR; hasPointer: BOOLEAN); 
		PROCEDURE ^ PatchArray(section: IntermediateCode.Section; pc: LONGINT; size: LONGINT); 
		PROCEDURE ^ ExportDesc(source: IntermediateCode.Section); 
		PROCEDURE ^ ExceptionArray(source: IntermediateCode.Section); 
		PROCEDURE ^ Name(section: IntermediateCode.Section; CONST name: ARRAY OF CHAR); 
		PROCEDURE ^ References(section: IntermediateCode.Section); 
		PROCEDURE ^ CommandArray(source: IntermediateCode.Section); 
		PROCEDURE ^ IsFirstDirectOccurence(import: SyntaxTree.Import): BOOLEAN; 
		PROCEDURE ^ ImportsArray(source: IntermediateCode.Section); 
		PROCEDURE ^ TypeInfoSection(source: IntermediateCode.Section); 
		PROCEDURE ^ ProcedureDescriptor(section: IntermediateCode.Section; procedureSection: IntermediateCode.Section); 
		PROCEDURE ^ MakeProcedureDescriptorTag(procedureSection: IntermediateCode.Section): IntermediateCode.Section; 
		PROCEDURE ^ ProcedureDescriptorPointer(section: IntermediateCode.Section; procedureSection: IntermediateCode.Section); 
		PROCEDURE ^ ProcedureDescriptorArray(section: IntermediateCode.Section; VAR numberProcs: LONGINT); 
		PROCEDURE ^ BasePointer(section: IntermediateCode.Section); 
		PROCEDURE ^ BaseObject(section: IntermediateCode.Section); 
		PROCEDURE ^ BaseRecord(section: IntermediateCode.Section); 
		PROCEDURE ^ ModuleDescriptor(section: IntermediateCode.Section); 
		PROCEDURE ^ ModuleSection(): IntermediateCode.Section; 
		PROCEDURE ^ NewModuleInfo; 
		PROCEDURE ^ Module(bodyProc: IntermediateCode.Section); 
		PROCEDURE ^ PatchCRC(crc: LONGINT); 
		PROCEDURE ^ PointerArray(source: IntermediateCode.Section; scope: SyntaxTree.Scope; VAR numberPointers: LONGINT); 
		PROCEDURE ^ SymbolSection(symbol: SyntaxTree.Symbol; CONST suffix: ARRAY OF CHAR; VAR pc: LONGINT): IntermediateCode.Section; 
		PROCEDURE ^ CheckTypeDeclaration(x: SyntaxTree.Type); 
	END MetaDataGenerator; 

	IntermediateBackend* = OBJECT (IntermediateCode.IntermediateBackend)
	VAR 
		trace-: BOOLEAN; 
		traceString-: SyntaxTree.IdentifierString; 
		traceModuleName-: SyntaxTree.IdentifierString; 
		newObjectFile-: BOOLEAN; 
		profile-: BOOLEAN; 
		noRuntimeChecks: BOOLEAN; 
		simpleMetaData-: BOOLEAN; 
		noAsserts: BOOLEAN; 
		optimize-: BOOLEAN; 
		cooperative-: BOOLEAN; 
		preregisterStatic-: BOOLEAN; 
		dump-: Basic.Writer; 
		cellsAreObjects: BOOLEAN; 
		preciseGC, trackLeave, writeBarriers: BOOLEAN; 
		experiment: BOOLEAN; 

		PROCEDURE ^  & InitIntermediateBackend*; 
		PROCEDURE ^ NumberParameterRegisters*(callingConvention: SyntaxTree.CallingConvention): SIZE; 
		PROCEDURE ^ ParameterRegister*(callingConvention: SyntaxTree.CallingConvention; type: IntermediateCode.Type; index: LONGINT): LONGINT; 
		PROCEDURE ^ GenerateIntermediate*(x: SyntaxTree.Module; supportedInstruction: SupportedInstructionProcedure; supportedImmediate: SupportedImmediateProcedure): Sections.Module; 
		PROCEDURE ^ SupportedImmediate*(CONST op: IntermediateCode.Operand): BOOLEAN; 
		PROCEDURE ^ ProcessSyntaxTreeModule*(syntaxTreeModule: SyntaxTree.Module): Formats.GeneratedModule; 
		PROCEDURE ^ ProcessIntermediateCodeModule*(intermediateCodeModule: Formats.GeneratedModule): Formats.GeneratedModule; 
		PROCEDURE ^ GetDescription*(VAR instructionSet: ARRAY OF CHAR); 
		PROCEDURE ^ SetNewObjectFile*(newObjectFile: BOOLEAN; simpleMetaData: BOOLEAN); 
		PROCEDURE ^ SetTraceModuleName(CONST name: ARRAY OF CHAR); 
		PROCEDURE ^ DefineOptions*(options: Options.Options); 
		PROCEDURE ^ GetOptions*(options: Options.Options); 
		PROCEDURE ^ DefaultSymbolFileFormat*(): Formats.SymbolFileFormat; 
	END IntermediateBackend; 

	; 
VAR 
	int8-, int16-, int32-, int64-, uint8-, uint16-, uint32-, uint64-, float32-, float64-: IntermediateCode.Type; 
	emptyOperand: IntermediateCode.Operand; 
	systemCalls: ARRAY NumberSystemCalls OF SyntaxTree.Symbol; 
	statCoopResetVariables: LONGINT; 
	statCoopModifyAssignments: LONGINT; 
	modifyAssignmentsPC: LONGINT; 
	statCoopNilCheck: LONGINT; 
	statCoopSwitch: LONGINT; 
	statCoopAssignProcedure: LONGINT; 
	statCoopTraceMethod: LONGINT; 
	statCoopResetProcedure: LONGINT; 
	statCoopTraceModule: LONGINT; 

	PROCEDURE ^ ResetStatistics*; 
	PROCEDURE ^ Statistics*; 
	PROCEDURE ^ GCD(a, b: LONGINT): LONGINT; 
	PROCEDURE ^ SCM(a, b: LONGINT): LONGINT; 
	PROCEDURE ^ CommonAlignment(a, b: LONGINT): LONGINT; 
	PROCEDURE ^ PassBySingleReference(parameter: SyntaxTree.Parameter; callingConvention: SyntaxTree.CallingConvention): BOOLEAN; 
	PROCEDURE ^ PassInRegister(parameter: SyntaxTree.Parameter; callingConvention: SyntaxTree.CallingConvention): BOOLEAN; 
	PROCEDURE ^ AddRegisterEntry(VAR queue: RegisterEntry; register: LONGINT; class: IntermediateCode.RegisterClass; type: IntermediateCode.Type); 
	PROCEDURE ^ RemoveRegisterEntry(VAR queue: RegisterEntry; register: LONGINT): BOOLEAN; 
	PROCEDURE ^ Assert(cond: BOOLEAN; CONST reason: ARRAY OF CHAR); 
	PROCEDURE ^ ReusableRegister(op: IntermediateCode.Operand): BOOLEAN; 
	PROCEDURE ^ EnsureBodyProcedure(moduleScope: SyntaxTree.ModuleScope); 
	PROCEDURE ^ GetSymbol*(scope: SyntaxTree.ModuleScope; CONST moduleName, symbolName: ARRAY OF CHAR): SyntaxTree.Symbol; 
	PROCEDURE ^ InitOperand(VAR op: Operand; mode: SHORTINT); 
	PROCEDURE ^ GetType*(system: Global.System; type: SyntaxTree.Type): IntermediateCode.Type; 
	PROCEDURE ^ BuildConstant(module: SyntaxTree.Module; value: SyntaxTree.Value; VAR adr: LONGINT): SyntaxTree.Constant; 
	PROCEDURE ^ HasPointers(scope: SyntaxTree.ProcedureScope): BOOLEAN; 
	PROCEDURE ^ IsVariableParameter(parameter: SyntaxTree.Parameter): BOOLEAN; 
	PROCEDURE ^ HasVariableParameters(scope: SyntaxTree.ProcedureScope): BOOLEAN; 
	PROCEDURE ^ HasExplicitTraceMethod(recordType: SyntaxTree.RecordType): BOOLEAN; 
	PROCEDURE ^ IsIntegerConstant(expression: SyntaxTree.Expression; VAR val: HUGEINT): BOOLEAN; 
	PROCEDURE ^ PowerOf2*(val: HUGEINT; VAR exp: LONGINT): BOOLEAN; 
	PROCEDURE ^ GetConstructor(record: SyntaxTree.RecordType): SyntaxTree.Procedure; 
	PROCEDURE ^ IsIntegerImmediate(CONST op: IntermediateCode.Operand; VAR value: LONGINT): BOOLEAN; 
	PROCEDURE ^ IsStrictlyPointerToRecord(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsUnsafePointer(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsPointerToRecord(type: SyntaxTree.Type; VAR recordType: SyntaxTree.RecordType): BOOLEAN; 
	PROCEDURE ^ IsArrayOfSystemByte(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsOpenArray(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsSemiDynamicArray(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsStaticArray(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ IsStaticMathArray(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ StaticMathArrayBaseType(type: SyntaxTree.Type): SyntaxTree.Type; 
	PROCEDURE ^ StaticArrayNumElements(type: SyntaxTree.Type): LONGINT; 
	PROCEDURE ^ StaticMathArrayNumElements(type: SyntaxTree.Type): LONGINT; 
	PROCEDURE ^ StaticArrayBaseType(type: SyntaxTree.Type): SyntaxTree.Type; 
	PROCEDURE ^ ArrayBaseType(type: SyntaxTree.Type): SyntaxTree.Type; 
	PROCEDURE ^ IsDelegate(type: SyntaxTree.Type): BOOLEAN; 
	PROCEDURE ^ DynamicDim(type: SyntaxTree.Type): LONGINT; 
	PROCEDURE ^ StaticSize(system: Global.System; type: SyntaxTree.Type): LONGINT; 
	PROCEDURE ^ IsImmediate(x: IntermediateCode.Operand): BOOLEAN; 
	PROCEDURE ^ IsAddress(x: IntermediateCode.Operand): BOOLEAN; 
	PROCEDURE ^ IsRegister(x: IntermediateCode.Operand): BOOLEAN; 
	PROCEDURE ^ GetRecordTypeName(recordType: SyntaxTree.RecordType; VAR name: Basic.SegmentedName); 
	PROCEDURE ^ ParametersSize(system: Global.System; procedureType: SyntaxTree.ProcedureType; isNested: BOOLEAN): LONGINT; 
	PROCEDURE ^ IsNested(procedure: SyntaxTree.Procedure): BOOLEAN; 
	PROCEDURE ^ InCellScope(scope: SyntaxTree.Scope): BOOLEAN; 
	PROCEDURE ^ ProcedureParametersSize*(system: Global.System; procedure: SyntaxTree.Procedure): LONGINT; 
	PROCEDURE ^ ToMemoryUnits*(system: Global.System; size: SIZE): LONGINT; 
	PROCEDURE ^ Get*(): Backend.Backend; 
	PROCEDURE ^ Nop(position: Basic.Position): IntermediateCode.Instruction; 
	PROCEDURE ^ Mov(position: Basic.Position; dest, src: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ MovReplace(position: Basic.Position; dest, src: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Conv(position: Basic.Position; dest, src: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Call*(position: Basic.Position; op: IntermediateCode.Operand; parSize: LONGINT): IntermediateCode.Instruction; 
	PROCEDURE ^ Exit(position: Basic.Position; pcOffset: LONGINT; callingConvention, unwind: LONGINT): IntermediateCode.Instruction; 
	PROCEDURE ^ Return(position: Basic.Position; res: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Result*(position: Basic.Position; res: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Trap(position: Basic.Position; nr: LONGINT): IntermediateCode.Instruction; 
	PROCEDURE ^ Br(position: Basic.Position; dest: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Breq(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Brne(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Brge(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Brlt(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Pop*(position: Basic.Position; op: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Push*(position: Basic.Position; op: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Neg(position: Basic.Position; dest, src: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Not(position: Basic.Position; dest, src: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Abs(position: Basic.Position; dest, src: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Mul(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Div(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Mod(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Sub(position: Basic.Position; dest: IntermediateCode.Operand; left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Add(position: Basic.Position; dest: IntermediateCode.Operand; left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ And(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Or(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Xor(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Shl(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Shr(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Rol(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Ror(position: Basic.Position; dest, left, right: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Cas(position: Basic.Position; dest, src, size: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Copy(position: Basic.Position; dest, src, size: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Fill(position: Basic.Position; dest, size, value: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Asm(position: Basic.Position; s: SyntaxTree.SourceCode; inRules, outRules: IntermediateCode.Rules): IntermediateCode.Instruction; 
	PROCEDURE ^ Data*(position: Basic.Position; op: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ SpecialInstruction(position: Basic.Position; subtype: SHORTINT; op1, op2, op3: IntermediateCode.Operand): IntermediateCode.Instruction; 
	PROCEDURE ^ Reserve(position: Basic.Position; units: LONGINT): IntermediateCode.Instruction; 
	PROCEDURE ^ LabelInstruction(position: Basic.Position): IntermediateCode.Instruction; 
	PROCEDURE ^ EnterImmediate*(data: IntermediateCode.Section; CONST vop: IntermediateCode.Operand): LONGINT; 
	PROCEDURE ^ Init; 
	PROCEDURE ^ IsExported(symbol: SyntaxTree.Symbol): BOOLEAN; 
BEGIN
END FoxIntermediateBackend.
