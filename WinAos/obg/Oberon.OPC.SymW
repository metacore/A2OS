MODULE OPC IN Oberon;
	IMPORT SYSTEM, OPT, OPL, OPO, OPM;
CONST 
	Undef = 0; 
	Byte = 1; 
	Bool = 2; 
	Char = 3; 
	SInt = 4; 
	Int = 5; 
	LInt = 6; 
	Real = 7; 
	LReal = 8; 
	Set = 9; 
	String = 10; 
	NilTyp = 11; 
	NoTyp = 12; 
	Pointer = 13; 
	ProcTyp = 14; 
	Comp = 15; 
	HInt = 16; 
	intSet = {SInt .. LInt}; 
	realSet = {Real, LReal}; 
	Basic = 1; 
	StaticArr = 2; 
	SDynArr = 3; 
	DynArr = 4; 
	OpenArr = 5; 
	Record = 6; 
	ArraySet = {StaticArr, SDynArr, DynArr, OpenArr}; 
	Nvar = 0; 
	Nvarpar = 1; 
	Nconst = 7; 
	Nproc = 9; 
	Ncall = 13; 
	Nret = 32; 
	Var = 1; 
	VarPar = 2; 
	Con = 3; 
	Fld = 4; 
	Typ = 5; 
	LProc = 6; 
	XProc = 7; 
	CProc = 9; 
	IProc = 10; 
	TProc = 13; 
	Reg = OPO.Reg; 
	Abs = OPO.Abs; 
	RegRel = OPO.RegRel; 
	Coc = OPO.Coc; 
	adr = 24; 
	cc = 25; 
	bit = 26; 
	lsh = 27; 
	rot = 28; 
	val = 29; 
	get8 = 30; 
	get16 = 31; 
	get32 = 32; 
	getfn = 24; 
	putfn = 25; 
	getrfn = 26; 
	putrfn = 27; 
	sysnewfn = 30; 
	movefn = 31; 
	hasBody = 1; 
	slNeeded = 3; 
	activeObj = 5; 
	locked = 6; 
	safe = 8; 
	internal = 0; 
	external = 1; 
	externalR = 2; 
	BaseTypeOffs =  -8; 
	MethodOffs =  -72; 
	ArrBlkFirstElem = 8; 
	ArrBlkLastDim = 12; 
	StaticLinkAdr = 8; 
	eql = 9; 
	neq = 10; 
	lss = 11; 
	leq = 12; 
	gtr = 13; 
	geq = 14; 
	false = 0; 
	true = 1; 
	nil = 0; 
	EQ = OPL.je; 
	NE = OPL.jne; 
	LT = OPL.jl; 
	LE = OPL.jle; 
	GT = OPL.jg; 
	GE = OPL.jge; 
	AB = OPL.ja; 
	AE = OPL.jae; 
	BL = OPL.jb; 
	BE = OPL.jbe; 
	CS = OPL.jc; 
	CC = OPL.jnc; 
	always = OPL.jmp; 
	never =  -1; 
	ld = OPL.ld; 
	store = OPL.store; 
	lea = OPL.lea; 
	push = OPL.push; 
	pop = OPL.pop; 
	ldProc = OPL.ldProc; 
	ldXProc = OPL.ldXProc; 
	ldbdw = OPL.ldbdw; 
	ldwdw = OPL.ldwdw; 
	ldbw = OPL.ldbw; 
	ldbdwu = OPL.ldbdwu; 
	ldwdwu = OPL.ldwdwu; 
	ldbwu = OPL.ldbwu; 
	putReg = OPL.putReg; 
	getReg = OPL.getReg; 
	add = OPL.add; 
	sub = OPL.sub; 
	mul = OPL.mul; 
	div = OPL.div; 
	mod = OPL.mod; 
	neg = OPL.neg; 
	abs = OPL.abs; 
	cmp = OPL.cmp; 
	je = OPL.je; 
	jne = OPL.jne; 
	jl = OPL.jl; 
	jle = OPL.jle; 
	jg = OPL.jg; 
	jge = OPL.jge; 
	ja = OPL.ja; 
	jae = OPL.jae; 
	jb = OPL.jb; 
	jbe = OPL.jbe; 
	jc = OPL.jc; 
	jnc = OPL.jnc; 
	jmp = OPL.jmp; 
	jmpReg = OPL.jmpReg; 
	sete = OPL.sete; 
	setne = OPL.setne; 
	setl = OPL.setl; 
	setle = OPL.setle; 
	setg = OPL.setg; 
	setge = OPL.setge; 
	seta = OPL.seta; 
	setae = OPL.setae; 
	setb = OPL.setb; 
	setbe = OPL.setbe; 
	setc = OPL.setc; 
	setnc = OPL.setnc; 
	te = OPL.te; 
	tne = OPL.tne; 
	tle = OPL.tle; 
	ta = OPL.ta; 
	tae = OPL.tae; 
	to = OPL.to; 
	trap = OPL.trap; 
	or = OPL.or; 
	xor = OPL.xor; 
	and = OPL.and; 
	not = OPL.not; 
	bt = OPL.bt; 
	btr = OPL.btr; 
	test = OPL.test; 
	bts = OPL.bts; 
	call = OPL.call; 
	callReg = OPL.callReg; 
	xcall = OPL.xcall; 
	ret = OPL.ret; 
	enter = OPL.enter; 
	leave = OPL.leave; 
	sal = OPL.sal; 
	sar = OPL.sar; 
	shr = OPL.shr; 
	rol = OPL.rol; 
	cld = OPL.cld; 
	repMovs = OPL.repMovs; 
	cmpString = OPL.cmpString; 
	cli = OPL.cli; 
	sti = OPL.sti; 
	in = OPL.in; 
	out = OPL.out; 
	assembler = OPL.assembler; 
	clear = OPL.clear; 
	std = OPL.std; 
	fload = OPL.fload; 
	fstore = OPL.fstore; 
	fist = OPL.fist; 
	fild = OPL.fild; 
	fadd = OPL.fadd; 
	fsub = OPL.fsub; 
	fmul = OPL.fmul; 
	fdiv = OPL.fdiv; 
	fabs = OPL.fabs; 
	fchs = OPL.fchs; 
	fcmp = OPL.fcmp; 
	phi = OPL.phi; 
	pushReg = OPL.pushReg; 
	popReg = OPL.popReg; 
	case = OPL.case; 
	entier = OPL.entier; 
	short = OPL.short; 
	label = OPL.label; 
	finlabel = OPL.finlabel; 
	newStat = OPL.newStat; 
	ESP = OPL.RiscESP; 
	FP = OPL.RiscFP; 
	none = OPL.none; 
	noScale = OPO.noScale; 
	notag = 1; 
	stdcall = 2; 
	cdecl = 3; 
	delegate = 5; 
	Nil* =  -1; 
	BUG = 40; 
TYPE 
	Item* = RECORD 
		mode*, scale*: SHORTINT; 
		mnolev*: LONGINT; 
		typ*: OPT.Struct; 
		node*: OPT.Node; 
		adr*, offs*, inx*, descReg*, descOffs*: LONGINT; 
	END; 

	Label* = LONGINT; 
VAR 
	level*: SHORTINT; 
	pc*: INTEGER; 
	True, False, Stack: Item; 
	ebp: Item; 
	formTab: ARRAY 16 OF SHORTINT; 
	CCtab: ARRAY 2 OF ARRAY ((geq - eql) + 1) OF INTEGER; 
	InvCCtab: ARRAY (((CC - EQ) DIV 32) + 1) OF INTEGER; 
	lastTD: Item; 
	delegateType: OPT.Struct; 

	PROCEDURE ^ Init*; 
	PROCEDURE ^ IncReg(pReg: LONGINT); 
	PROCEDURE ^ InitInstr(op: INTEGER; mode, form: SHORTINT; node: OPT.Node); 
	PROCEDURE ^ NewStat*(textPos: LONGINT); 
	PROCEDURE ^ GenLoad(op: INTEGER; VAR z, x: Item); 
	PROCEDURE ^ GenPush(VAR x: Item); 
	PROCEDURE ^ GenPop(VAR x: Item); 
	PROCEDURE ^ GenLoadProc(op: INTEGER; VAR z: Item; val: LONGINT; node: OPT.Node); 
	PROCEDURE ^ GenStore(op: INTEGER; VAR z, x: Item); 
	PROCEDURE ^ GenPopReg(hint, form: SHORTINT); 
	PROCEDURE ^ Gen0(op: INTEGER); 
	PROCEDURE ^ Gen1(op: INTEGER; adr: LONGINT; node: OPT.Node); 
	PROCEDURE ^ Gen2(op: INTEGER; VAR z, x: Item); 
	PROCEDURE ^ Gen3(op: INTEGER; VAR z, x, y: Item); 
	PROCEDURE ^ PushRegs*; 
	PROCEDURE ^ GenCall(op: INTEGER; adr, parSize: LONGINT; node: OPT.Node); 
	PROCEDURE ^ GenFlags(op: INTEGER; VAR x, y: Item); 
	PROCEDURE ^ GenSetC(op: INTEGER; VAR z: Item); 
	PROCEDURE ^ GenRepMovs(VAR z, x, nofElem: Item; moveSize: SHORTINT; reverse: BOOLEAN); 
	PROCEDURE ^ GenPhi(reg0, reg1: LONGINT); 
	PROCEDURE ^ MakeCon*(VAR cons: Item; typ: OPT.Struct; val: LONGINT); 
	PROCEDURE ^ SetCC(VAR x: Item; cc: LONGINT); 
	PROCEDURE ^ DefFinallyLabel*(n: OPT.Node); 
	PROCEDURE ^ DefLabel*(VAR L: Label); 
	PROCEDURE ^ FixLinkWith(L, val: Label); 
	PROCEDURE ^ FixLink*(L: Label); 
	PROCEDURE ^ MergedLinks*(L0, L1: Label): Label; 
	PROCEDURE ^ Jmp*(VAR loc: Label; node: OPT.Node); 
	PROCEDURE ^ Jcc*(VAR x: Item; VAR loc: Label; node: OPT.Node); 
	PROCEDURE ^ Jncc*(VAR x: Item; VAR loc: Label; node: OPT.Node); 
	PROCEDURE ^ CompleteSL(VAR x: Item); 
	PROCEDURE ^ loadAdr(VAR x: Item); 
	PROCEDURE ^ loadf(VAR x: Item); 
	PROCEDURE ^ load(VAR x: Item); 
	PROCEDURE ^ NextWord(VAR z: Item; y: Item); 
	PROCEDURE ^ DeRef*(VAR x: Item); 
	PROCEDURE ^ GetTdAdr*(VAR typ: OPT.Struct; VAR tag: Item); 
	PROCEDURE ^ TypeTest*(VAR x: Item; testtyp: OPT.Struct; guard, equal, varRec: BOOLEAN); 
	PROCEDURE ^ Procedure*(VAR proc: Item; n: OPT.Node); 
	PROCEDURE ^ CheckOverflow(VAR x: Item); 
	PROCEDURE ^ CheckIntRange(VAR x: Item; form: SHORTINT); 
	PROCEDURE ^ CheckRealRange(VAR x: Item; form: SHORTINT); 
	PROCEDURE ^ CheckIndex(VAR index, len: Item); 
	PROCEDURE ^ ChangeType(VAR item: Item; form: SHORTINT); 
	PROCEDURE ^ SetElem*(VAR z, x: Item); 
	PROCEDURE ^ Convert*(VAR x: Item; form: SHORTINT); 
	PROCEDURE ^ Include*(VAR z, x: Item; incl: BOOLEAN); 
	PROCEDURE ^ MoveCoc(VAR z, y: Item); 
	PROCEDURE ^ Relation*(VAR x: Item); 
	PROCEDURE ^ Cmp*(VAR z, x, y: Item; rel: INTEGER); 
	PROCEDURE ^ In*(VAR z, x, y: Item); 
	PROCEDURE ^ SetRange*(VAR z, x, y: Item); 
	PROCEDURE ^ Not*(VAR z, x: Item); 
	PROCEDURE ^ Neg*(VAR z, x: Item); 
	PROCEDURE ^ AbsVal*(VAR z, x: Item); 
	PROCEDURE ^ Cap*(VAR z, x: Item); 
	PROCEDURE ^ Odd*(VAR z, x: Item); 
	PROCEDURE ^ Ash*(VAR z, x, y: Item); 
	PROCEDURE ^ Add*(VAR z, x, y: Item; f: INTEGER); 
	PROCEDURE ^ Sub*(VAR z, x, y: Item; f: INTEGER); 
	PROCEDURE ^ Mul*(VAR z, x, y: Item; f: INTEGER); 
	PROCEDURE ^ Div*(VAR z, x, y: Item; f: INTEGER); 
	PROCEDURE ^ Mod*(VAR z, x, y: Item); 
	PROCEDURE ^ CondAnd*(VAR x: Item); 
	PROCEDURE ^ And*(VAR z, x, y: Item); 
	PROCEDURE ^ CondOr*(VAR x: Item); 
	PROCEDURE ^ Or*(VAR z, x, y: Item); 
	PROCEDURE ^ SYSmop*(VAR z, x: Item; subcl: SHORTINT; typ: OPT.Struct); 
	PROCEDURE ^ Mem(VAR x: Item); 
	PROCEDURE ^ SYSdop*(VAR z, x, y: Item; subcl: SHORTINT); 
	PROCEDURE ^ SYSgetput*(VAR z, x: Item; getfn: BOOLEAN); 
	PROCEDURE ^ SYSportio*(VAR z, x: Item; pin: BOOLEAN); 
	PROCEDURE ^ SYSgetputReg*(VAR z, x: Item; getrfn: BOOLEAN); 
	PROCEDURE ^ SYSinterrupt*(clear: BOOLEAN); 
	PROCEDURE ^ Msk*(VAR z, x, y: Item); 
	PROCEDURE ^ Field*(VAR x: Item; offset: LONGINT); 
	PROCEDURE ^ Method*(VAR x: Item; obj: OPT.Object); 
	PROCEDURE ^ MakeVar(VAR x: Item; var: OPT.Object); 
	PROCEDURE ^ ArrayLen(VAR len: Item; arr: Item; n: LONGINT); 
	PROCEDURE ^ Len*(VAR len, x, y: Item); 
	PROCEDURE ^ ArrayBaseSize(VAR len: Item; arr: Item); 
	PROCEDURE ^ TypeSize(x: Item; VAR size: Item; VAR step, scale: SHORTINT); 
	PROCEDURE ^ Length(VAR len, x: Item); 
	PROCEDURE ^ loadDynArr(VAR z: Item); 
	PROCEDURE ^ Index*(VAR z, index: Item); 
	PROCEDURE ^ MoveBlock(VAR z, x, size: Item; moveSize: SHORTINT); 
	PROCEDURE ^ MoveBlockReversed(VAR z, x, size: Item; moveSize: SHORTINT); 
	PROCEDURE ^ Move(VAR z, x: Item); 
	PROCEDURE ^ SYSmove*(VAR z, x, nofBytes: Item); 
	PROCEDURE ^ Copy*(VAR z, x: Item); 
	PROCEDURE ^ Assign*(VAR z, x: Item); 
	PROCEDURE ^ IncDec*(VAR z, x: Item; increment: BOOLEAN); 
	PROCEDURE ^ MulDim*(VAR nofelem, len: Item); 
	PROCEDURE ^ PushLen*(VAR z: Item); 
	PROCEDURE ^ PopLen*(VAR block: Item); 
	PROCEDURE ^ NewSys*(VAR z, x: Item); 
	PROCEDURE ^ NewArray*(VAR z, nofelem: Item; nofdim: LONGINT; typ: OPT.Struct; dimUsed: BOOLEAN); 
	PROCEDURE ^ NewRec*(VAR z: Item; typ: OPT.Struct); 
	PROCEDURE ^ CallRecBody*(VAR self, body: Item; typ: OPT.Struct); 
	PROCEDURE ^ PushArrLen(fp: OPT.Object; VAR ap, dest: Item; useDest: BOOLEAN); 
	PROCEDURE ^ PushComp(fp: OPT.Object; VAR ap: Item); 
	PROCEDURE ^ ParRecord(fp: OPT.Object; VAR ap: Item; apIsDeref, alwaysRef: BOOLEAN); 
	PROCEDURE ^ Parameter*(VAR ap: Item; fp: OPT.Object; apIsDeref, alwaysRef: BOOLEAN); 
	PROCEDURE ^ PrepRetDest*(z: Item): LONGINT; 
	PROCEDURE ^ PushRetDesc*(VAR x, tos: Item); 
	PROCEDURE ^ CorrectStackAdr*(VAR x: Item; size, dynblocks: LONGINT); 
	PROCEDURE ^ ResetStack*(dynblocks: LONGINT); 
	PROCEDURE ^ AllocateStatic*(VAR tos: Item; size: LONGINT); 
	PROCEDURE ^ RemoveStatic*(size: LONGINT); 
	PROCEDURE ^ CopyDynArr(VAR x, y: Item); 
	PROCEDURE ^ ArgSize(par: OPT.Object): LONGINT; 
	PROCEDURE ^ EndCall(proc: OPT.Object; typ: OPT.Struct); 
	PROCEDURE ^ Call*(VAR x: Item; proc: OPT.Object; node: OPT.Node); 
	PROCEDURE ^ PopResult*(n: OPT.Node; VAR z: Item); 
	PROCEDURE ^ AllocSDynArr*(VAR proc: OPT.Object); 
	PROCEDURE ^ Enter*(proc: OPT.Object; dataSize: LONGINT; node: OPT.Node); 
	PROCEDURE ^ Return*(VAR res: Item; proc: OPT.Object); 
	PROCEDURE ^ Exit*(proc: OPT.Object); 
	PROCEDURE ^ Lock*(self, excl: Item); 
	PROCEDURE ^ Unlock*(self, excl: Item); 
	PROCEDURE ^ Await*(z, self, y: Item); 
	PROCEDURE ^ Trap*(n: LONGINT; node: OPT.Node); 
	PROCEDURE ^ GenAsm*(n: OPT.Node); 
	PROCEDURE ^ GenDimTrap*(VAR len: Item); 
	PROCEDURE ^ Case*(VAR x: Item; low, high: LONGINT; VAR tab: LONGINT; VAR L: Label; node: OPT.Node); 
	PROCEDURE ^ CaseFixup*(tab: LONGINT; elseLabel: Label; len: LONGINT); 
BEGIN
END OPC.
