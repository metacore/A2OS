MODULE Reflection;
	IMPORT Modules, Streams, SYSTEM, Machine, Heaps, Objects, Trace, Kernel;
CONST 
	ShowAllProcs = TRUE; 
	MaxFrames = 128; 
	MaxString = 64; 
	MaxArray = 8; 
	MaxCols = 70; 
	Sep = \"  "\; 
	SepLen = 2; 
	LineDelay = 0; 
	sfTypeNone* = 0X; 
	sfTypeCHAR* = 1X; 
	sfTypeCHAR8* = 2X; 
	sfTypeCHAR16* = 3X; 
	sfTypeCHAR32* = 4X; 
	sfTypeRANGE* = 5X; 
	sfTypeSHORTINT* = 6X; 
	sfTypeINTEGER* = 7X; 
	sfTypeLONGINT* = 8X; 
	sfTypeHUGEINT* = 9X; 
	sfTypeWORD* = 0AX; 
	sfTypeLONGWORD* = 0BX; 
	sfTypeSIGNED8* = 0CX; 
	sfTypeSIGNED16* = 0DX; 
	sfTypeSIGNED32* = 0EX; 
	sfTypeSIGNED64* = 0FX; 
	sfTypeUNSIGNED8* = 10X; 
	sfTypeUNSIGNED16* = 11X; 
	sfTypeUNSIGNED32* = 12X; 
	sfTypeUNSIGNED64* = 13X; 
	sfTypeREAL* = 14X; 
	sfTypeLONGREAL* = 15X; 
	sfTypeCOMPLEX* = 16X; 
	sfTypeLONGCOMPLEX* = 17X; 
	sfTypeBOOLEAN* = 18X; 
	sfTypeSET* = 19X; 
	sfTypeANY* = 1AX; 
	sfTypeOBJECT* = 1BX; 
	sfTypeBYTE* = 1CX; 
	sfTypeADDRESS* = 1DX; 
	sfTypeSIZE* = 1EX; 
	sfTypeIndirect* = 1FX; 
	sfTypeRecord* = 20X; 
	sfTypePointerToRecord* = 21X; 
	sfTypePointerToArray* = 22X; 
	sfTypeOpenArray* = 23X; 
	sfTypeStaticArray* = 24X; 
	sfTypeDynamicArray* = 25X; 
	sfTypeMathStaticArray* = 26X; 
	sfTypeMathOpenArray* = 27X; 
	sfTypeMathTensor* = 28X; 
	sfTypeDelegate* = 29X; 
	sfTypeENUM* = 2AX; 
	sfTypeCELL* = 2BX; 
	sfTypePORT* = 2CX; 
	sfIN* = 0X; 
	sfOUT* = 1X; 
	flagDelegate* = 0; 
	flagConstructor* = 1; 
	sfAbsolute* = 0X; 
	sfRelative* = 1X; 
	sfIndirect* = 2X; 
	sfScopeBegin* = 0F0X; 
	sfScopeEnd* = 0F1X; 
	sfProcedure* = 0F2X; 
	sfVariable* = 0F3X; 
	sfTypeDeclaration* = 0F4X; 
	sfModule* = 0FFX; 
TYPE 
	Name = ARRAY 128 OF CHAR; 

	Meta* = RECORD 
		module-: Modules.Module; 
		refs-: Modules.Bytes; 
		offset*: SIZE; 
	END; 

	Search = RECORD 
		name: ARRAY 256 OF CHAR; 
		nameOffset: SIZE; 
		minLevel: LONGINT; 
		pc: ADDRESS; 
		pos: SIZE; 
		found: BOOLEAN; 
	END; 

	Variable* = RECORD 
		adr-: ADDRESS; 
		type-, size-, n-: SIZE; 
		tdadr-: ADDRESS; 
	END; 
VAR 
	modes: ARRAY 25 OF CHAR; 
	trace: Streams.Writer; 

	PROCEDURE ^ CheckHeapAddress(address: ADDRESS): BOOLEAN; 
	PROCEDURE ^ Wait(w: Streams.Writer); 
	PROCEDURE ^ Expect(pos: SIZE; b: BOOLEAN): BOOLEAN; 
	PROCEDURE ^ GetChar*(refs: Modules.Bytes; VAR offset: SIZE): CHAR; 
	PROCEDURE ^ SkipChar*(VAR offset: SIZE); 
	PROCEDURE ^ GetAddress*(refs: Modules.Bytes; VAR offset: SIZE): ADDRESS; 
	PROCEDURE ^ SkipAddress*(VAR offset: SIZE); 
	PROCEDURE ^ GetSize*(refs: Modules.Bytes; VAR offset: SIZE): SIZE; 
	PROCEDURE ^ SkipSize*(VAR offset: SIZE); 
	PROCEDURE ^ GetSet*(refs: Modules.Bytes; VAR offset: SIZE): SET; 
	PROCEDURE ^ SkipSet*(VAR offset: SIZE); 
	PROCEDURE ^ GetString*(refs: Modules.Bytes; VAR offset: SIZE; VAR string: ARRAY OF CHAR); 
	PROCEDURE ^ SkipString*(refs: Modules.Bytes; VAR offset: SIZE); 
	PROCEDURE ^ GetFullName*(refs: Modules.Bytes; offset: SIZE; VAR name: ARRAY OF CHAR); 
	PROCEDURE ^ ThisTypeByAdr(adr: ADDRESS; VAR m: Modules.Module; VAR t: Modules.TypeDesc); 
	PROCEDURE ^ WriteType*(w: Streams.Writer; adr: ADDRESS); 
	PROCEDURE ^ WriteProc0(w: Streams.Writer; mod: Modules.Module; pc, fp: ADDRESS; VAR refs: Modules.Bytes; VAR refpos: SIZE; VAR base: ADDRESS); 
	PROCEDURE ^ WriteBasicValue*(w: Streams.Writer; type: CHAR; adr: ADDRESS; VAR size: SIZE); 
	PROCEDURE ^ OnHeapOrStack(adr: ADDRESS; low, high: ADDRESS): BOOLEAN; 
	PROCEDURE ^ WriteValueString*(w: Streams.Writer; adr: ADDRESS; maxLen: SIZE; low, high: ADDRESS); 
	PROCEDURE ^ WriteMathArray*(w: Streams.Writer; adr: ADDRESS; low, high: ADDRESS); 
	PROCEDURE ^ WriteValue*(w: Streams.Writer; refs: Modules.Bytes; VAR offset: SIZE; adr: ADDRESS; low, high: ADDRESS); 
	PROCEDURE ^ WriteVariable*(w: Streams.Writer; refs: Modules.Bytes; VAR offset: SIZE; base: ADDRESS; low, high: ADDRESS); 
	PROCEDURE ^ WriteVariables*(w: Streams.Writer; refs: Modules.Bytes; VAR offset: SIZE; base: ADDRESS; low, high: ADDRESS); 
	PROCEDURE ^ SkipType*(refs: Modules.Bytes; VAR offset: SIZE); 
	PROCEDURE ^ SkipProcedure*(refs: Modules.Bytes; VAR offset: SIZE); 
	PROCEDURE ^ SkipVariable*(refs: Modules.Bytes; VAR offset: SIZE); 
	PROCEDURE ^ SkipTypeDeclaration*(refs: Modules.Bytes; VAR offset: SIZE); 
	PROCEDURE ^ SkipModule*(refs: Modules.Bytes; VAR offset: SIZE); 
	PROCEDURE ^ SkipScope*(refs: Modules.Bytes; VAR offset: SIZE); 
	PROCEDURE ^ FindString(refs: Modules.Bytes; VAR offset: SIZE; level: LONGINT; VAR find: Search); 
	PROCEDURE ^ FindInProcedure(refs: Modules.Bytes; VAR offset: SIZE; level: LONGINT; VAR find: Search); 
	PROCEDURE ^ FindInVariable(refs: Modules.Bytes; VAR offset: SIZE; level: LONGINT; VAR find: Search); 
	PROCEDURE ^ FindInTypeDeclaration(refs: Modules.Bytes; VAR offset: SIZE; level: LONGINT; VAR find: Search); 
	PROCEDURE ^ FindInModule(refs: Modules.Bytes; VAR offset: SIZE; level: LONGINT; VAR find: Search); 
	PROCEDURE ^ FindInScope(refs: Modules.Bytes; VAR offset: SIZE; level: LONGINT; VAR find: Search); 
	PROCEDURE ^ InitSearch(VAR search: Search); 
	PROCEDURE ^ FindByName*(refs: Modules.Bytes; offset: SIZE; CONST name: ARRAY OF CHAR; skipFirstSymbol: BOOLEAN): SIZE; 
	PROCEDURE ^ FindByAdr*(refs: Modules.Bytes; offset: SIZE; pc: ADDRESS): SIZE; 
	PROCEDURE ^ WriteProc*(w: Streams.Writer; pc: ADDRESS); 
	PROCEDURE ^ ModuleState*(w: Streams.Writer; mod: Modules.Module); 
	PROCEDURE ^ CheckBP(bp: ADDRESS): ADDRESS; 
	PROCEDURE ^ StackTraceBack*(w: Streams.Writer; pc, bp: ADDRESS; low, high: ADDRESS; long, overflow: BOOLEAN); 
	PROCEDURE ^ WriteProcess*(w: Streams.Writer; p: Objects.Process); 
	PROCEDURE ^ GetVariableAdr*(fp, pc: ADDRESS; CONST name: ARRAY OF CHAR): SIZE; 
	PROCEDURE ^ GetProcedureName*(pc: ADDRESS; VAR name: ARRAY OF CHAR; VAR startpc: ADDRESS); 
	PROCEDURE ^ FindVar*(mod: Modules.Module; CONST name: ARRAY OF CHAR; VAR v: Variable): BOOLEAN; 
	PROCEDURE ^ WriteVar*(w: Streams.Writer; v: Variable; VAR col: LONGINT); 
	PROCEDURE ^ ReportType*(w: Streams.Writer; refs: Modules.Bytes; VAR offset: SIZE); 
	PROCEDURE ^ ReportProcedure*(w: Streams.Writer; refs: Modules.Bytes; VAR offset: SIZE); 
	PROCEDURE ^ ReportVariable*(w: Streams.Writer; refs: Modules.Bytes; VAR offset: SIZE); 
	PROCEDURE ^ ReportTypeDeclaration*(w: Streams.Writer; refs: Modules.Bytes; VAR offset: SIZE); 
	PROCEDURE ^ ReportScope*(w: Streams.Writer; refs: Modules.Bytes; VAR offset: SIZE); 
	PROCEDURE ^ ReportModule*(w: Streams.Writer; refs: Modules.Bytes; offset: SIZE); 
	PROCEDURE ^ Report*(w: Streams.Writer; refs: Modules.Bytes; offset: SIZE); 
	PROCEDURE ^ TraceH(process: Objects.Process; pc, bp: ADDRESS; stacklow, stackhigh: ADDRESS); 
	PROCEDURE ^ TraceProcesses*; 
	PROCEDURE ^ Test*; 
BEGIN
END Reflection.
