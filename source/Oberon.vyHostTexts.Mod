(* This file has been generated by SpotPP 0.1d1 at  10.07.1999 13:57:55
from   vy/src/Mpp/vyHostTexts.Mpp - Last modified at  10.07.1999 13:57:55
using flags: S3
Do not change this file. Apply changes to the master file only.  *)


MODULE vyHostTexts IN Oberon;  (*   gs *)
(* Copyright notice:

This file is part of Voyager
Copyright (C) 1993-2002 Project Voyager, StatLab Heidelberg ; (C) 1993-2002 G. Sawitzki et al.

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

Copy of the GNU Lesser General Public License can be found in the file COPYING.TXT
Report any problems as soon as possible to voyager@statlab.uni-heidelberg.de
*)


(* 	(c) Project Voyager, StatLab Heidelberg
*)

(* 	System.Free vyHostTexts* ~
Component:	Tools
Contents:		voyager Host dependent text module
Based on vyTexts v0.0a.3
Comments from vyTexts v0.0a.3:
Local adaptation of Texts. Name convention should follow those of Texts.
These are low level routines which should not depent upon any voyager data structures.

Provide standard output formats.
Find fail-safe output channels.
Do not mix scanner and parser functionality.
Guarantee a common scanner across platforms  (hacked for MacOberon 4.10x)

vyTexts keeps one global Writer w and a Text Log.
jb	14.8.01 bugfix in OpenScanner
gs	InsertGadgetsAndScroll changed for S32.1
gs	12.3.95 added SetLog
fof	17.1.95 changed InsertLog (scrolling)
gs	08.08.94 added msg formats v0r0d3
gs	07.08.94 changed vyInsert to InsertLog

added initialization
renamed Msg2 to MsgStS <string tab string>
(*! remove/check for unnecessary buffer access *)
(*! bubble up append to Oberon.Log/errors to vyHosts *)
(*! support error messages w. attributes *)
(*! use these routines as common message and report routines - channel all IO here *)
(*! check all use of Msg whether Note would be better*)
(*! make sure dangling Scanner does not block a Text *)

*)
(*
001118: fof defunct color 10, is lightblue on windows
*)

IMPORT
	Objects, Oberon, Display, Texts, Viewers, TextFrames, Fonts, PanelDocs
	, TextGadgets, TextDocs, Gadgets, Documents, Desktops, vyPortability; (*System3 Only*)
	(*= The abstract output system has two channels, a general output channnel, and a separate
	message channel. Both channels are supposed to handle Oberon text elements. *)
CONST
	idversion* = 'vyHostTexts S3R2.1 v0.0d1';
	(** Err log message levels *)
	cNotify* = 10;
	cWarning* = 20;
	cAlert* = 30;

	cRed = 1;   cBlue = 3;   cGreen = 8;   col7 = 7;   col10 = 10;   cBlack = 15;
	cSpace = 32X;
	cTab = 9X;

	(*** Types *)
TYPE

	(**  Text attributes *)
	Style* = POINTER TO StyleDesc;
	StyleDesc* = RECORD
	END;

	CharStyle* = POINTER TO CharStyleDesc;
	CharStyleDesc* = RECORD (StyleDesc)
	END;

	RulerStyle* = POINTER TO RulerStyleDesc;
	RulerStyleDesc* = RECORD (StyleDesc)
	END;

	ParaStyle* = POINTER TO ParaStyleDesc;
	ParaStyleDesc* = RECORD (CharStyleDesc)
	END;

	NumberStyle* = POINTER TO NumberStyleDesc;
	NumberStyleDesc* = RECORD (StyleDesc)
	END;

	FontItem = POINTER TO FontItemDesc;
	FontItemDesc = RECORD
		(* sentinel on start *)
		Font: Fonts.Font;
		prev: FontItem
	END;
	(*** Global variables *)
VAR
	(* Parameter input: from PIO In.Mod *)
	T* : 	Texts.Text;
	S* : 	Texts.Scanner;
	beg: SIGNED32;
	w* : 	Texts.Writer;   	(*= a general writer. Output goes to Log *)
	werr* : 	Texts.Writer;   (* =a writer for exception messages. Output goes to Log *)
	Log* : Texts.Text;   (*= a persistent text. May be mapped to Oberon.Log *)
	msgsep* : CHAR;   	(*= a one character message separator eg. cSpace or cTab. *)

	CaretHasPriority* : BOOLEAN;
	StdOut: Display.Frame;
	DefaultFont* , TableFont* : Fonts.Font;  PrevFont  : FontItem;
	hexchars: ARRAY 17 OF CHAR;
	foundObj : BOOLEAN;  (* fof 0103 for finding objects in Display Space *)
	NewDocument*: Documents.Document;

	newF-: TextGadgets.Frame;
	(*** Procedures *)

PROCEDURE InRealRange (x: FLOAT64): BOOLEAN;
BEGIN
	RETURN (x >= MIN(FLOAT32)) & (x <= MAX(FLOAT32))
END InRealRange;

PROCEDURE WReal* (VAR w: Texts.Writer;   x: FLOAT64;   prec: SIGNED16);
BEGIN
	IF (x >= MIN(FLOAT32)) & (x <= MAX(FLOAT32)) THEN	Texts.WriteReal(w, SHORT(x), prec) ELSE Texts.WriteLongReal(w, x, prec) END
END WReal;

PROCEDURE DebugNote (s: ARRAY OF CHAR);
BEGIN Texts.WriteString(w, idversion);   Texts.WriteString(w, ' DebugNote:');   Texts.WriteString(w, s);
	Texts.WriteLn(w);   Texts.Append(Log, werr.buf)
END DebugNote;

(** Interface to unify System3/4/F *)
PROCEDURE WriteRealFix* (VAR W: Texts.Writer;   x: FLOAT64;   n, f, E: SIGNED32);
BEGIN
	(*(* V4 *)
	Texts.WriteRealFix(W,x, n, f);
	*)
	(*S3 *)
	IF (x >= MIN(FLOAT32)) & (x <= MAX(FLOAT32)) THEN
		Texts.WriteRealFix(W, SHORT(x), n, f, E)
	ELSE Texts.WriteLongRealFix(W, SHORT(x), n, f, E)
	END
END WriteRealFix;

PROCEDURE InsertErrW* (level: SIGNED16;   TB: Texts.Writer);   	(*vs 0.1d1 fof *)
	(* Append buffer text to error log *)
	(*! should become fail-safe *)
	(*! force level attributes. So far, level is not supported. *)
BEGIN	Texts.Append(Log, TB.buf) END InsertErrW;

PROCEDURE InsertErr* (level: SIGNED16;   buf: Texts.Buffer);   	(*vs 0.1d1 fof *)
	(* Append buffer text to error log *)
	(*! should become fail-safe *)
	(*! force level attributes. So far, level is not supported. *)
BEGIN	Texts.Append(Log, buf) END InsertErr;

(* PROCEDURE ParcBeforeInsertion* (): TextFrames.Parc;
(*vs 0.01d *)
VAR
Out: Viewers.Viewer;
OutTF : TextFrames.Frame;
OutText: Text;
OutPos,ParcPos: SIGNED32;
caret: BOOLEAN;
Parc: TextFrames.Parc;
BEGIN
GetInsertionPoint(Out,OutTF,OutText,OutPos,caret);
TextFrames.ParcBefore(OutText,OutPos,Parc,ParcPos);
IF  (ParcPos < 0 )THEN
RETURN NIL;
ELSE
RETURN Parc;
END;
END ParcBeforeInsertion; *)(* s3 *)
(*____________________________________________________*)

PROCEDURE NoteAttrib (VAR  tw: Texts.Writer;   level: SIGNED16);

	(*! use font styles as well  for visually impaired *)
	(*! copy alerts and warnings to log *)
BEGIN	IF level < cNotify THEN Texts.SetColor(tw, cBlack)
	ELSIF level < cWarning  THEN Texts.SetColor(tw, cGreen)
	ELSIF level < cAlert  THEN  Texts.SetColor(tw, col7)(* fof changed, col10 is lightblue on windows *)
	ELSE Texts.SetColor(tw, cRed)
	END
END NoteAttrib;

PROCEDURE AppendToText* (VAR t: Texts.Text;   VAR w: Texts.Writer);
BEGIN Texts.Append(t, w.buf)
END AppendToText;

PROCEDURE AppendToLog* (VAR w: Texts.Writer);
BEGIN Texts.Append(Log, w.buf)
END AppendToLog;

PROCEDURE Show* (name: ARRAY OF CHAR;  VAR w: Texts.Writer);
	(*= Open a new display, and append contents of w: Contents is not saved. *)
	VAR D: Objects.Object;       F: TextGadgets.Frame;
	VAR T: Texts.Text;
BEGIN NEW(T);
	Texts.Open(T, name);
	Texts.Append(T, w.buf);
	TextDocs.NewDoc;       D := Objects.NewObj(Documents.Document);
	IF D # NIL THEN WITH D: Documents.Document DO
			NEW(F);       TextGadgets.Init(F(TextGadgets.Frame), T, FALSE);
		D.W := 600;       Documents.Init(D, F); Desktops.ShowDoc(D) END
	END
END Show;

(** Diagnostic messages *)

PROCEDURE Note* (level: SIGNED16;   s: ARRAY OF CHAR);   	(*vs 0.1d0 gs *)
BEGIN NoteAttrib(werr, level);
	Texts.WriteString(werr, s);   Texts.WriteLn(werr);   AppendToText(Log, werr);
NoteAttrib(werr, 0) END Note;

PROCEDURE NoteSS* (level: SIGNED16;   s1, s2: ARRAY OF CHAR);   	(*vs 0.1d0 gs *)
BEGIN NoteAttrib(werr, level);
	Texts.WriteString(werr, s1);   Texts.Write(werr, msgsep);
	Texts.WriteString(werr, s2);
	Texts.WriteLn(werr);   AppendToText(Log, werr);
NoteAttrib(werr, 0) END NoteSS;

PROCEDURE NoteSSS* (level: SIGNED16;   s1, s2, s3: ARRAY OF CHAR);   	(*vs 0.1d0 gs *)
BEGIN NoteAttrib(werr, level);
	Texts.WriteString(werr, s1);   Texts.Write(werr, msgsep);
	Texts.WriteString(werr, s2);   Texts.Write(werr, msgsep);
	Texts.WriteString(werr, s3);
	Texts.WriteLn(werr);   AppendToText(Log, werr);
NoteAttrib(werr, 0) END NoteSSS;

PROCEDURE NoteSI* (level: SIGNED16;   s: ARRAY OF CHAR;   i: SIGNED32);   	(*vs 0.1d0 gs *)
	(* string integer string integer *)
BEGIN NoteAttrib(werr, level);
	Texts.WriteString(werr, s);   Texts.WriteInt(werr, i, 0);   Texts.Write(werr, ' ');
	Texts.WriteLn(werr);   AppendToText(Log, werr);
NoteAttrib(werr, 0) END NoteSI;

PROCEDURE NoteSIS* (level: SIGNED16;   s: ARRAY OF CHAR;   i: SIGNED32;   s1: ARRAY OF CHAR);   	(*vs 0.1d0 gs *)
	(* string integer string integer *)
BEGIN NoteAttrib(werr, level);
	Texts.WriteString(werr, s);   Texts.WriteInt(werr, i, 0);   Texts.Write(werr, ' ');
	Texts.WriteString(werr, s1);
	Texts.WriteLn(werr);   AppendToText(Log, werr);
NoteAttrib(werr, 0) END NoteSIS;

PROCEDURE NoteSISI* (level: SIGNED16;   s: ARRAY OF CHAR;   i: SIGNED32;   s1: ARRAY OF CHAR;   i1: SIGNED32);   	(*vs 0.1d0 gs *)
	(* string integer string integer *)
BEGIN NoteAttrib(werr, level);
	Texts.WriteString(werr, s);   Texts.Write(werr, msgsep);
	Texts.WriteInt(werr, i, 0);   Texts.Write(werr, msgsep);
	Texts.WriteString(werr, s1);   Texts.Write(werr, msgsep);
	Texts.WriteInt(werr, i1, 0);
	Texts.WriteLn(werr);   AppendToText(Log, werr);
NoteAttrib(werr, 0) END NoteSISI;

(** Initialization *)
PROCEDURE CheckTime;
	VAR t, now, day, mon, yr: SIGNED32;
BEGIN Oberon.GetClock(t, now);
	day := now MOD 32;  mon := now DIV 32 MOD 16;  yr := now DIV 512 MOD 128;
	(*	vyHostTexts.MsgSI('Day ',day);vyHostTexts.MsgSI(' Mon ',mon); vyHostTexts.MsgSI(' Yr ',yr); *)
	Note(cNotify, 'Launching Voyager (c) G. Sawitzki, StatLab Heidelberg 1994-2002')
	(*
	IF (yr>100) & (mon>3) THEN Note(cAlert,'Please contact voyager@statlab.uni-heidelberg.de for a recent version.') END;
	*)
END CheckTime;

PROCEDURE OpenScanner* (VAR s: Texts.Scanner): BOOLEAN;   	(*vs 0.1d1 gs *)
	(* modified from PIO: In.Mod
	Returns true if open and Text
	*)
	(*! support full set of command conventions as in PO p.40 *)
VAR
	end, time: SIGNED32;
	V: Viewers.Viewer;
	ScannerDone: BOOLEAN;
BEGIN
	ScannerDone := FALSE;   (* default *)
	Texts.OpenScanner(s, Oberon.Par.text, Oberon.Par.pos);    Texts.Scan(s);
	IF (s.class = Texts.Char) & (s.c = '^') THEN
		(* start input stream at beginning of selection *)
		Oberon.GetSelection(T, beg, end, time);
		IF time >= 0 THEN  Texts.OpenScanner(s, T, beg);    ScannerDone := ~s.eot
		ELSE  Note(cAlert, 'Input parameter is ^, but nothing is selected.');   ScannerDone := FALSE
		END
	ELSIF (s.class = Texts.Char) & (s.c = '*') THEN
		(* start input stream at beginning of text in marked viewer *)
		V := Oberon.MarkedViewer();
		IF ~Oberon.Pointer.on THEN Note(cAlert, 'Pointer not visible');    ScannerDone := FALSE
		ELSIF (V.dsc # NIL) & (V.dsc.next IS TextFrames.Frame) THEN
			T := V.dsc.next(TextFrames.Frame).text;    beg := 0;
			Texts.OpenScanner(s, T, beg);    ScannerDone := ~s.eot
		ELSE  Note(cAlert, 'Marked viewer not a text viewer');    ScannerDone := FALSE
		END
	ELSE
		(* start input stream after command name *)
		T := Oberon.Par.text;    beg := Oberon.Par.pos;
		Texts.OpenScanner(s, T, beg);    ScannerDone := ~s.eot (* jb 14.8.01 - s instead of S *)
	END;
	RETURN ScannerDone
END OpenScanner;

PROCEDURE DoOpenLog* (logname: ARRAY OF CHAR);
	VAR                 D: Documents.Document;
	F: TextGadgets.Frame;
	C: Oberon.CaretMsg;

BEGIN
	D := Documents.Open(logname);
	IF (D # NIL) & (D.dsc # NIL) & (D.dsc IS TextGadgets.Frame) THEN
		F := D.dsc(TextGadgets.Frame);
		newF := F;
		Oberon.Defocus;
		Desktops.ShowDoc(D);
		C.id := Oberon.set;
		C.F :=  F;   C.car := F;
		C.text := F.text;   C.pos := F.text.len;
		Display.Broadcast(C);
		CheckTime;
		(* StdOut := D.dsc; CaretHasPriority := FALSE *)(* uncoment that, if you want output to new frame only *)
	ELSE newF := NIL
	END
END DoOpenLog;


PROCEDURE SetCaret*;
	VAR C: Oberon.CaretMsg;
BEGIN
	IF newF # NIL THEN
		C.res := - 1;
		C.id := Oberon.set;
		C.F :=  newF;   C.car := newF;
		C.text := newF.text;   C.pos := newF.text.len;
		Display.Broadcast(C)
	END
END SetCaret;


PROCEDURE OpenLog*;
	VAR S: Texts.Scanner;
BEGIN
	Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos);   Texts.Scan(S);
	IF S.class = Texts.Name THEN
		DoOpenLog(S.s)
	END
END OpenLog;

(** Write tables *)
PROCEDURE WriteTableStyle* (VAR W: Texts.Writer);
CONST ctabdist = 60;
	VAR prevfont: FontItem;
	obj: Objects.Object;      BM: Objects.BindMsg;      oldfnt: Objects.Library;       OL: Objects.Library;
	i: SIGNED16;

BEGIN
	(*! insert style parc or gadget *)
	obj := Gadgets.CreateObject("TextGadgets.NewStyleProc");
	IF obj # NIL THEN
		WITH obj: TextGadgets.Style DO  obj.width := 600;       (*obj.mode set by NewStyleProc *)obj.noTabs := 32;
			FOR i := 0 TO obj.noTabs - 1 DO obj.tab[i] := (i + 1) * ctabdist     END;      (*obj.text := OutT; *)(*?? needed?? gs *)
		END;
		NEW(OL);       Objects.OpenLibrary(OL);       BM.lib := OL;       Objects.Stamp(BM);       obj.handle(obj, BM);
		oldfnt := W.lib;       Texts.SetFont(W, OL);       Texts.Write(W, CHR(obj.ref));       Texts.SetFont(W, oldfnt)

	END;

	IF (W.lib # NIL) & (W.lib IS Fonts.Font) THEN
		NEW(prevfont);  prevfont.prev := PrevFont;  prevfont.Font := W.lib(Fonts.Font);
	PrevFont := prevfont END;
	Texts.SetFont(W, TableFont)
END WriteTableStyle;

PROCEDURE WritePrevStyle* (VAR W: Texts.Writer);
BEGIN
	(*! insert style parc or gadget *)
	Texts.SetFont(W, PrevFont.Font); PrevFont := PrevFont.prev
END WritePrevStyle;

PROCEDURE WriteInt* (VAR W: Texts.Writer;   i: SIGNED32);
	(*! replace by smatrt choice *)
BEGIN
	IF (i >= MIN(SIGNED16)) & (i <= MAX(SIGNED16)) THEN
		Texts.WriteInt(W, i, 6)
	ELSE
		Texts.WriteInt(W, i, 12)
	END
END WriteInt;

PROCEDURE WriteLongIntTab* (VAR W: Texts.Writer;   len: SIGNED32;   x: ARRAY OF SIGNED32;   start: SIGNED32;   n: SIGNED32);
BEGIN
	IF len <= 0 THEN RETURN END;
	Texts.WriteInt(W, x[start], n);
	len := len + start;   INC(start);
	WHILE start < len DO Texts.Write(W, cTab);   Texts.WriteInt(W, x[start], n);   INC(start) END
END WriteLongIntTab;


PROCEDURE WriteIntTab* (VAR W: Texts.Writer;   len: SIGNED32;   x: ARRAY OF SIGNED16;   start: SIGNED32;   n: SIGNED32);
BEGIN
	IF len <= 0 THEN RETURN END;
	Texts.WriteInt(W, x[start], n);
	len := len + start;   INC(start);
	WHILE start < len DO Texts.Write(W, cTab);   Texts.WriteInt(W, x[start], n);   INC(start) END
END WriteIntTab;

PROCEDURE WriteLongRealTab* (VAR W: Texts.Writer;   len: SIGNED32;   x: ARRAY OF FLOAT64;   start: SIGNED32;   n: SIGNED32);
BEGIN
	IF len <= 0 THEN RETURN END;
	Texts.WriteLongReal(W, x[start], n);
	len := len + start;   INC(start);
	WHILE start < len DO Texts.Write(W, cTab);   Texts.WriteLongReal(W, x[start], n);   INC(start) END
END WriteLongRealTab;

PROCEDURE WriteLongRealFixTab* (VAR W: Texts.Writer;   len: SIGNED32;   x: ARRAY OF FLOAT64;   start: SIGNED32;   n, f, E: SIGNED32);
BEGIN
	IF len <= 0 THEN RETURN END;
	Texts.WriteLongRealFix(W, x[start], n, f, E);
	len := len + start;   INC(start);
	WHILE start < len DO Texts.Write(W, cTab);   Texts.WriteLongRealFix(W, x[start], n, f, E);   INC(start) END
END WriteLongRealFixTab;

PROCEDURE WriteRealTab* (VAR W: Texts.Writer;   len: SIGNED32;   x: ARRAY OF FLOAT32;   start: SIGNED32;   n: SIGNED32);
BEGIN
	IF len <= 0 THEN RETURN END;
	Texts.WriteReal(W, x[start], n);
	len := len + start;   INC(start);
	WHILE start < len DO Texts.Write(W, cTab);   Texts.WriteReal(W, x[start], n);   INC(start) END
END WriteRealTab;

PROCEDURE WriteRealFixTab* (VAR W: Texts.Writer;   len: SIGNED32;   x: ARRAY OF FLOAT32;   start: SIGNED32;   n, f, E: SIGNED32);
BEGIN
	IF len <= 0 THEN RETURN END;
	Texts.WriteRealFix(W, x[start], n, f, E);
	len := len + start;   INC(start);
	WHILE start < len DO Texts.Write(W, cTab);   Texts.WriteRealFix(W, x[start], n, f, E);   INC(start) END
END WriteRealFixTab;
(* IO *)

PROCEDURE WriteReal* (VAR W: Texts.Writer;   x: FLOAT64);
	(*! replace by smatrt choice *)
BEGIN
	IF (x >= MIN(FLOAT32)) & (x <= MAX(FLOAT32)) THEN
		Texts.WriteRealFix(W, SHORT(x), 12, 3, 3)
	ELSE
		Texts.WriteLongRealFix(W, SHORT(x), 12, 3, 3)
	END
END WriteReal;

PROCEDURE WriteBoolTab* (VAR w: Texts.Writer;   count: SIGNED32;   VAR a: ARRAY OF BOOLEAN;   offset, step: SIGNED32);
BEGIN  ASSERT(offset >= 0);
	IF count > 0 THEN
		count := offset + count * step;
		IF step > 0 THEN
			WHILE offset < count DO
				IF a[offset] THEN Texts.Write(w, "T") ELSE Texts.Write(w, "F") END;
			offset := offset + step END (*WHILE*)
		ELSE
			WHILE offset > count DO
				IF a[offset] THEN Texts.Write(w, "T") ELSE Texts.Write(w, "F") END;
			offset := offset + step END (*WHILE*)
		END;
	Texts.WriteLn(w)END
END WriteBoolTab;

(** S3 specific *)

PROCEDURE SetStdOutput* (F: Display.Frame);
BEGIN
	IF F =  NIL THEN StdOut := NIL;   RETURN END;
	IF (F IS TextFrames.Frame) OR  (F IS TextGadgets.Frame) THEN StdOut := F END
END SetStdOutput;

PROCEDURE GetInsertionPoint (VAR OFR: Display.Frame;   VAR OT: Texts.Text;   VAR OPos: SIGNED32;   VAR caretconst: BOOLEAN);
	VAR caret: BOOLEAN;

PROCEDURE Caret (): BOOLEAN;
	VAR Cmsg: Oberon.CaretMsg;
BEGIN
	OFR := NIL;   OT := NIL;
	Cmsg.id := Oberon.get;   Cmsg.car := NIL;   Cmsg.text := NIL;   Cmsg.F := NIL;   Cmsg.res := - 1;
	Display.Broadcast(Cmsg);
	IF Cmsg.res < 0  THEN RETURN FALSE END;
	ASSERT(Cmsg.car # NIL, 100);
	OFR := Cmsg.car;   OT := Cmsg.text;   OPos := Cmsg.pos;
	RETURN TRUE
END Caret;

PROCEDURE Visible (F: Display.Frame): BOOLEAN;
	VAR Fmsg: Display.LocateMsg;
BEGIN
	Fmsg.F := F;   Fmsg.res := - 1;   Display.Broadcast(Fmsg);
	IF Fmsg.res = - 1 THEN
		RETURN FALSE
	ELSE
		RETURN TRUE
	END
END Visible;

BEGIN

	caret := Caret();
	caretconst := FALSE;

	IF CaretHasPriority THEN
		IF caret THEN RETURN END
	END;

	IF  StdOut # NIL THEN
		IF Visible(StdOut) THEN
			IF OFR = StdOut THEN
				RETURN
			ELSE
				IF StdOut IS TextGadgets.Frame THEN OT := StdOut(TextGadgets.Frame).text
				ELSIF StdOut IS TextFrames.Frame THEN OT := StdOut(TextFrames.Frame).text
				END;
				OFR := StdOut;   OPos := OT.len;   caretconst := caret;   RETURN
			END
		ELSIF caret THEN
			RETURN
		END
	(* ELSIF caret THEN
		RETURN *)
	ELSE
		OFR := NIL;   OT := Oberon.Log;   OPos := Oberon.Log.len;   RETURN
	END
END GetInsertionPoint;

PROCEDURE InsertBufferAndScroll (B: Texts.Buffer;   VAR OutFrame: Display.Frame;   OutText: Texts.Text;   OutPos: SIGNED32;
VAR newPos: SIGNED32);
	VAR Cmsg: Oberon.CaretMsg;
BEGIN
	IF OutFrame # NIL THEN
		Cmsg.id := Oberon.set;    Cmsg.car := OutFrame;   Cmsg.text := OutText;    Cmsg.F := OutFrame ;   Cmsg.pos := OutPos;   Cmsg.res := - 1;
		Display.Broadcast(Cmsg)
	END;
	IF OutText = NIL THEN OutText := Oberon.Log END;
	newPos := OutPos + B.len;
	Texts.Insert(OutText, OutPos, B);
	IF OutFrame # NIL THEN
		Cmsg.id := Oberon.set;    Cmsg.car := OutFrame;   Cmsg.text := OutText;    Cmsg.F := OutFrame ;   Cmsg.pos := newPos;   Cmsg.res := - 1;
		Display.Broadcast(Cmsg)
	END
END InsertBufferAndScroll;

PROCEDURE TempHandle (obj: Objects.Object;  VAR msg: Objects.ObjMsg);  (* fof 0103 for finding objects in Display space *)
BEGIN
	IF msg IS Display.DisplayMsg THEN WITH msg: Display.DisplayMsg DO
		foundObj := TRUE
	END
	END
END TempHandle;

(*fof,  to integrate Gadget if no position mark is set: *)
PROCEDURE InsertGadgetAndScroll (O: Objects.Object;   VAR OutFrame: Display.Frame;   OutText: Texts.Text;   OutPos: SIGNED32;
VAR newPos: SIGNED32);
	VAR Cmsg: Oberon.CaretMsg;   Dmsg: Display.ConsumeMsg;   Disp: Display.DisplayMsg;  orighandle: Objects.Handler;
	msg: Display.DisplayMsg;  d: Documents.Document;
BEGIN
	NewDocument := NIL;
	IF OutFrame = NIL THEN
		WITH O: Gadgets.Frame DO
			Gadgets.Integrate(O);
			foundObj := FALSE;
			orighandle := O.handle;
			O.handle := TempHandle;
			msg.F := O;  msg.device := Display.screen;  msg.id := Display.full;  msg.res := - 1;
			Display.Broadcast(msg);
			O.handle := orighandle;
			IF ~ foundObj THEN (* no insert point found, open own document *)
				vyPortability.LockOberon;
				PanelDocs.NewDoc;
				d := Objects.NewObj(Documents.Document);
				NewDocument := d;
				PanelDocs.InitDoc(d, O.W, O.H);
				Documents.Init(d, O(Gadgets.Frame));
				(*
				d.W := O.W; d.H := O.H;
				*)
				Desktops.ShowDoc(d);
				vyPortability.UnlockOberon
			END;
			RETURN
		END
	END;

	Cmsg.id := Oberon.set;    Cmsg.car := OutFrame;   Cmsg.text := OutText;
	Cmsg.F := OutFrame ;   Cmsg.pos := OutPos;   Cmsg.res := - 1;
	Display.Broadcast(Cmsg);
	Dmsg.F := OutFrame;   Dmsg.obj := O;   Dmsg.id := 1;
	Display.Broadcast(Dmsg);
	Disp.F := O(Display.Frame);
	(*Disp.id := Display.frame; *)
	Disp.device := Display.screen;   Disp.id := Display.full;   (* gs 9.11.96 *)
	Display.Broadcast(Disp)
END InsertGadgetAndScroll;

(*
PROCEDURE InsertGadgetAndScroll (O: Objects.Object;  VAR OutFrame: Display.Frame;  OutText: Texts.Text;  OutPos: SIGNED32;
VAR newPos: SIGNED32);
VAR Cmsg: Oberon.CaretMsg;  Dmsg: Display.ConsumeMsg;  Disp: Display.DisplayMsg;
BEGIN
IF OutFrame = NIL THEN Gadgets.Integrate(O);  RETURN END;

Cmsg.id := Oberon.set;   Cmsg.car := OutFrame;  Cmsg.text := OutText;
Cmsg.F := OutFrame ;  Cmsg.pos := OutPos;  Cmsg.res := - 1;
Display.Broadcast(Cmsg);
Dmsg.F := OutFrame;  Dmsg.obj := O;  Dmsg.id := 1;
Display.Broadcast(Dmsg);
Disp.F := O(Display.Frame);
(*Disp.id := Display.frame; *)
Disp.device := Display.screen;  Disp.id := Display.full;  (* gs 9.11.96 *)
Display.Broadcast(Disp)
END InsertGadgetAndScroll;
*)


PROCEDURE InsertLog* (B: Texts.Buffer);
	(* Insert buffer text at caret position - if any *)
	(*! should become central fail-safe output procedure *)
	VAR OutTF: Display.Frame;   OutText: Texts.Text;   OutPos, newPos : SIGNED32;   CaretConst: BOOLEAN;   Cmsg: Oberon.CaretMsg;
BEGIN
	ASSERT(B # NIL);
	GetInsertionPoint(OutTF, OutText, OutPos, CaretConst);
	IF CaretConst THEN
		Cmsg.id := Oberon.get;   Cmsg.F := NIL;   Cmsg.car := NIL;   Cmsg.text := NIL;   Cmsg.res := - 1;
		Display.Broadcast(Cmsg)
	END;
	InsertBufferAndScroll(B, OutTF, OutText, OutPos, newPos);
	IF CaretConst THEN
		Cmsg.id := Oberon.set;   Cmsg.F := Cmsg.car;
		Display.Broadcast(Cmsg)
	END
END InsertLog;

PROCEDURE InsertGadget* (G: Objects.Object);
	VAR OutTF: Display.Frame;   OutText: Texts.Text;   OutPos, newPos : SIGNED32;   CaretConst: BOOLEAN;   Cmsg: Oberon.CaretMsg;
BEGIN
	ASSERT(G # NIL);
	GetInsertionPoint(OutTF, OutText, OutPos, CaretConst);
	IF CaretConst THEN
		Cmsg.id := Oberon.get;   Cmsg.F := NIL;   Cmsg.car := NIL;   Cmsg.text := NIL;   Cmsg.res := - 1;
		Display.Broadcast(Cmsg)
	END;
	InsertGadgetAndScroll(G, OutTF, OutText, OutPos, newPos);
	IF CaretConst THEN
		Cmsg.id := Oberon.set;   Cmsg.F := Cmsg.car;
		Display.Broadcast(Cmsg)
	END;
	(*ASSERT(G.lib#NIL); *)
END InsertGadget;

PROCEDURE GetCurWidth* (): SIGNED16;
	VAR OutTF: Display.Frame;   OutText: Texts.Text;   OutPos : SIGNED32;   b: BOOLEAN;   s: TextGadgets.Style;
BEGIN
	GetInsertionPoint(OutTF, OutText, OutPos, b);
	IF OutTF = NIL THEN  RETURN Viewers.curW DIV 2 END;
	IF OutTF IS TextGadgets.Frame THEN
		s := TextGadgets.FindStyle(OutText, OutPos);
		IF s # NIL THEN RETURN  s.width END
	END;
	RETURN OutTF.W
END GetCurWidth;


(* PROCEDURE ParcBeforeInsertion* (): TextFrames.Parc;
(*vs 0.01d *)
VAR
Out: Viewers.Viewer;
OutTF : TextFrames.Frame;
OutText: Texts.Text;
OutPos,ParcPos: SIGNED32;
caret: BOOLEAN;
Parc: TextFrames.Parc;
BEGIN
GetInsertionPoint(Out,OutTF,OutText,OutPos,caret);
TextFrames.ParcBefore(OutText,OutPos,Parc,ParcPos);
IF  (ParcPos < 0 )THEN
RETURN NIL;
ELSE
RETURN Parc;
END;
END ParcBeforeInsertion; *)(* s3 *)
(*____________________________________________________*)
(** Log messages *)
PROCEDURE MsgCat* ( s: ARRAY OF CHAR);   	(*vs 0.1d0 gs  add a message to log. No sep, no new line *)
BEGIN Texts.WriteString(w, s);   InsertLog(w.buf) END MsgCat;

PROCEDURE Msg* ( s: ARRAY OF CHAR);   	(*vs 0.1d0 gs message text and new line*)
BEGIN Texts.WriteString(w, s);   Texts.WriteLn(w);   InsertLog(w.buf) END Msg;

PROCEDURE MsgSS* ( s1, s2: ARRAY OF CHAR);   	(*vs 0.1d0 gs *)
	(* String  String>*)
BEGIN Texts.WriteString(w, s1);   Texts.Write(w, msgsep);   Msg(s2) END MsgSS;

PROCEDURE MsgI* ( i: SIGNED32);   	(*vs 0.1d0 gs *)
BEGIN Texts.WriteInt(w, i, 0);   Texts.WriteLn(w);   InsertLog(w.buf) END MsgI;

PROCEDURE MsgSHex* ( s1: ARRAY OF CHAR; i: SIGNED32);
	VAR s2: ARRAY 32 OF CHAR; j: SIGNED16;
BEGIN s2 := '0000000000H';
	FOR j := 9 TO 1 BY - 1 DO
	s2[j] := hexchars[(i MOD 16) ];  i := i DIV 16  END;
	MsgSS(s1, s2)
END MsgSHex;

PROCEDURE MsgSI* ( s1: ARRAY OF CHAR;   i: SIGNED32);   	(*vs 0.1d0 gs  String Integer>*)
BEGIN Texts.WriteString(w, s1);   Texts.Write(w, msgsep);   MsgI(i) END MsgSI;

PROCEDURE MsgSISI* ( s1: ARRAY OF CHAR;   i: SIGNED32;   s2: ARRAY OF CHAR;   j: SIGNED32);   	(*vs 0.1d0 gs  String space Integer>*)
BEGIN Texts.WriteString(w, s1);   Texts.Write(w, msgsep);
	Texts.WriteInt(w, i, 0);   Texts.Write(w, msgsep);
MsgSI(s2, j) END MsgSISI;

PROCEDURE MsgSR* ( s1: ARRAY OF CHAR;   x: FLOAT64);   	(*vs 0.1d1 gs *)
	(*! find proper default format for this and other real output*)
BEGIN Texts.WriteString(w, s1);   Texts.Write(w, msgsep);
	WReal(w, x, 10);   Texts.WriteLn(w);   InsertLog(w.buf)
END MsgSR;

PROCEDURE MsgSRR* ( s1: ARRAY OF CHAR;   x, y: FLOAT64);   	(*vs 0.1d0 gs *)
BEGIN Texts.WriteString(w, s1);   Texts.Write(w, msgsep);
	WReal(w, x, 10);   Texts.Write(w, msgsep);
	WReal(w, y, 10);   Texts.Write(w, msgsep);
	Texts.WriteLn(w);   InsertLog(w.buf)
END MsgSRR;

PROCEDURE MsgSRSR* ( s1: ARRAY OF CHAR;   x: FLOAT64;   s2: ARRAY OF CHAR;   y: FLOAT64);   	(*vs 0.1d0 gs *)
BEGIN Texts.WriteString(w, s1);   Texts.Write(w, msgsep);
	WReal(w, x, 10);   Texts.Write(w, msgsep);
	Texts.WriteString(w, s2);   Texts.Write(w, msgsep);
	WReal(w, y, 10);   Texts.Write(w, msgsep);
	Texts.WriteLn(w);   InsertLog(w.buf)
END MsgSRSR;

(*! add support for patterned matrices and 2dim *)

PROCEDURE DebugTest*;
BEGIN
	MsgSS(idversion, " **Dump sample Msg");
	NoteSS(cNotify, idversion, " **Dump sample notification note");
	NoteSS(cWarning, idversion, " **Dump sample warning note");
	NoteSS(cAlert, idversion, " **Dump sample alert note");
	MsgSS(idversion, " **Dump sample Msg done")
END DebugTest;

(** Dumps *)
PROCEDURE DumpBool* (VAR w: Texts.Writer;   VAR a: ARRAY OF BOOLEAN);
	VAR i, count: SIZE;
BEGIN
	WriteTableStyle(w);
	count := LEN(a); i := 0;
	WHILE i < count DO IF i > 0 THEN Texts.Write(w, cTab) END;
		IF a[i] THEN Texts.Write(w, "T") ELSE Texts.Write(w, "F") END;
		INC(i)
	END;
	Texts.WriteLn(w); WritePrevStyle(w)
END DumpBool;

PROCEDURE DumpReal* (VAR w: Texts.Writer;    VAR a: ARRAY OF FLOAT32;   prec: SIGNED16);
	VAR i, count: SIZE;
BEGIN   WriteTableStyle(w);
	count := LEN(a); i := 0;
	WHILE i < count DO
		Texts.WriteReal(w, a[i], prec);   INC(i)
	END;
	Texts.WriteLn(w); WritePrevStyle(w)
END DumpReal;

PROCEDURE DumpLongreal* (VAR w: Texts.Writer;     VAR a: ARRAY OF FLOAT64;   prec: SIGNED16);
	VAR i, count: SIZE;
BEGIN   WriteTableStyle(w);
	count := LEN(a); i := 0;
	WHILE i < count DO
		Texts.WriteLongReal(w, a[i], prec);   INC(i)
	END;
	Texts.WriteLn(w); WritePrevStyle(w)
END DumpLongreal;

PROCEDURE DumpInteger* (VAR w: Texts.Writer;     VAR a: ARRAY OF SIGNED16;   prec: SIGNED16);
	VAR i, count: SIZE;
BEGIN WriteTableStyle(w);
	count := LEN(a);   i := 0;
	WHILE i < count DO
		Texts.WriteInt(w, a[i], prec);   INC(i)
	END;
	Texts.WriteLn(w); WritePrevStyle(w)
END DumpInteger;

PROCEDURE DumpLongint* (VAR w: Texts.Writer;    VAR a: ARRAY OF SIGNED32;   prec: SIGNED16);
	VAR i, count: SIZE;
BEGIN   WriteTableStyle(w);
	count := LEN(a); i := 0;
	WHILE i < count DO
		Texts.WriteInt(w, a[i], prec);   INC(i)
	END;
	Texts.WriteLn(w); WritePrevStyle(w)
END DumpLongint;

(** Summaries *)
(*! These routines may be improved *)
PROCEDURE SummaryBool* (VAR w: Texts.Writer;   count: SIGNED32;   VAR a: ARRAY OF BOOLEAN);
	VAR i: SIGNED32;
BEGIN Texts.WriteString(w, "Summary for boolean array");   Texts.WriteLn(w);   i := 0;
	WHILE i < count DO
		IF a[i] THEN Texts.Write(w, "T") ELSE Texts.Write(w, "F") END;
		INC(i)
	END;
	Texts.WriteLn(w)
END SummaryBool;

PROCEDURE SummaryReal* (VAR w: Texts.Writer;   count: SIGNED32;   VAR a: ARRAY OF FLOAT32;   prec: SIGNED16);
	VAR i: SIGNED32;
BEGIN Texts.WriteString(w, "Summary for real array ");
	Texts.WriteString(w, " count=");   Texts.WriteInt(w, count, 0);
	Texts.WriteLn(w);   i := 0;
	WHILE i < count DO
		Texts.WriteReal(w, a[i], prec);   INC(i)
	END;
	Texts.WriteLn(w)
END SummaryReal;

PROCEDURE SummaryLongreal* (VAR w: Texts.Writer;   count: SIGNED32;   VAR a: ARRAY OF FLOAT64;   prec: SIGNED16);
	VAR i: SIGNED32;
BEGIN Texts.WriteString(w, "Summary for longreal array ");
	Texts.WriteString(w, " count=");   Texts.WriteInt(w, count, 0);
	Texts.WriteLn(w);   i := 0;
	WHILE i < count DO
		Texts.WriteLongReal(w, a[i], prec);   INC(i)
	END;
	Texts.WriteLn(w)
END SummaryLongreal;

PROCEDURE SummaryInteger* (VAR w: Texts.Writer;   count: SIGNED32;   VAR a: ARRAY OF SIGNED16;   prec: SIGNED16);
	VAR i: SIGNED32;
BEGIN Texts.WriteString(w, "Summary for integer array ");
	Texts.WriteString(w, " count=");   Texts.WriteInt(w, count, 0);
	Texts.WriteLn(w);   i := 0;
	WHILE i < count DO
		Texts.WriteInt(w, a[i], prec);   INC(i)
	END;
	Texts.WriteLn(w)
END SummaryInteger;

PROCEDURE SummaryLongint* (VAR w: Texts.Writer;   count: SIGNED32;   VAR a: ARRAY OF SIGNED32;   prec: SIGNED16);
	VAR i: SIGNED32;
BEGIN Texts.WriteString(w, "Summary for longinteger array ");
	Texts.WriteString(w, " count=");   Texts.WriteInt(w, count, 0);
	Texts.WriteLn(w);   i := 0;
	WHILE i < count DO
		Texts.WriteInt(w, a[i], prec);   INC(i)
	END;
	Texts.WriteLn(w)
END SummaryLongint;

BEGIN
	msgsep := ' ';  hexchars := '0123456789ABCDEF';
	Log := Oberon.Log;
	Texts.OpenWriter(w);   Texts.OpenWriter(werr);
	StdOut := NIL;
	CaretHasPriority := TRUE;
	(* Table formatting support *)
	DefaultFont := Fonts.Default;
	TableFont := Fonts.This('Courier10.Scn.Fnt');
	IF TableFont = NIL THEN TableFont := Fonts.Default END;
	NEW(PrevFont);  PrevFont.Font := Fonts.Default; PrevFont.prev := PrevFont
END  vyHostTexts.
